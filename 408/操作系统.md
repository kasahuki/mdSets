<center>
     <font size="50">操作系统</font>
</center>

---

**复习时==通览全局== ==理清结构== 再==深究细节==**！！！！

# 第一章

## 1.操作系统的概念、功能

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915005200289.png)

---

![image-20240915093036428](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915093036428.png)





![image-20240915093542670](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915093542670.png)





![image-20240915094323224](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094323224.png)

==**联机**==就是终端写命令一步一步操作 

==**脱机**==就是执行脚本批处理文件持续执行命令







![image-20240915094938372](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094938372.png)

---





## 2.操作系统的特征

==主要任务：弄清并发和并行 同步和异步以及操作系统的异步性的区别== 

![image-20240915094333194](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094333194.png)



![image-20240915094344084](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094344084.png)

![image-20240915094351429](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094351429.png)



![image-20240915094406060](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094406060.png)







![image-20240915094413541](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094413541.png)



![image-20240915094433740](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094433740.png)





![image-20240915094443450](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094443450.png)

## 3.操作系统的发展和分类

![image-20240915095055175](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915095055175.png)

### 手工操作阶段

![image-20240918164856888](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918164856888.png)



### 批处理阶段-单道批处理

![image-20240918164935048](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918164935048.png)

![image-20240918165025965](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165025965.png)

### 多道批处理

![image-20240918165128791](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165128791.png)

### 分时操作系统

![image-20240918165136060](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165136060.png)

### 实时操作系统

![image-20240918165144623](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165144623.png)

### 其他操作系统

![image-20240918165153761](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165153761.png)



## 4.操作系统的运行机制

![image-20240918165733241](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165733241.png)

linux指令为==交互式命令接口==

### 内核（kernel）程序 与 应用程序



![image-20240918165745144](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165745144.png)

### 特权指令和非特权指令

![image-20240918173439655](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173439655.png)

### 内核态和用户态

![image-20240918173451311](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173451311.png)

![image-20240918173458471](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173458471.png)

### 中断--内中断和外中断

![image-20240918173551424](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173551424.png)

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173600041.png)

### 陷入指令

<img src="https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173657012.png" alt="image-20240918173657012" style="zoom:50%;" />



![image-20240918173947661](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173947661.png)

![image-20240918173957209](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173957209.png)

### 中断分类总结

![image-20240918174009573](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918174009573.png)



![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173856154.png)

查询中断处理程序位置-->中断向量表

![image-20240918174305391](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918174305391.png)



## 5.虚拟机

![image-20240918174536756](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918174536756.png)



![image-20240918191809543](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918191809543.png)

指令如果只分特权和非特权的话，那么任何一条特权指令的的使用都要用虚拟机管理程序去截获，

所以对这个特权进行更精确的划分，就可以保证上层操作系统调用时就不用虚拟机管理程序管

### ==重点！！ 两种虚拟机区别==

![image-20240918193812028](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918193812028.png)

### 系统调用与库函数的区别

![image-20240918192333030](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192333030.png)



![image-20240918192357234](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192357234.png)

![image-20240918192417777](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192417777.png)

<b>==因为系统内核操作的就是涉及资源的分配==</b>

![image-20240918192436373](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192436373.png)

### 系统调用的过程



![image-20240918192559512](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192559512.png)

![image-20240918192605290](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192605290.png)

![image-20240918192627694](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192627694.png)



# 第二章

## 1.进程与线程

**程序**:是静态的，就是个存放在**磁盘**里的可执行文件，就是一系列的指令集合。
**进程(Process)**:是**动态**的，是程序的一次执行过程
==同一个程序多次执行会对应多个进程==





### 进程的组成---PCB(进程控制块)

![image-20240915101145095](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915101145095.png)

![image-20240915101329910](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915101329910.png)

#### ==程序的运行机制==

![image-20240915101336745](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915101336745.png)



![image-20240915101342672](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915101342672.png)

#### ==进程的特征==

![image-20240915101359469](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915101359469.png)



## 2. 进程的状态和转换

![image-20250213122636833](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213122636833.png)

![image-20250213122819582](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213122819582.png)

**在进程运行的过程中，可能会请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应)**

**在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU,并让它进入“阻塞态”**

**当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行**

![image-20250213123054448](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213123054448.png)

![image-20250213123222658](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213123222658.png)

单CPU情况下，**同一时刻只会有一个进程处于运行态**，**多核CPU情况**下，可能有多个进程处于运行态

---

进程PCB中，会有一个**变量state**来表示进程的当前状态。如：1表示创建态、2表示就绪态、3表示运行态.为了对同一个状态下的各个进程进行统一的管理，**操作系统会将各个进程的PCB组织起来。**

![image-20250213123500180](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213123500180.png)

大部分都使用的是链接方式



![img](https://raw.githubusercontent.com/kasahuki/os_test/main/img/image-20250213123528155.png)

## 3.进程控制

简化理解：反正进程控制就是要实现进程状态转换

**原语：**原子性的语句

![image-20250213124029315](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213124029315.png)

![image-20250213130021911](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213130021911.png)

![image-20250213130221279](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213130221279.png)

 **进程之间独立**，不共享数据，互不干扰

**子进程**是**由主进程创建的独立进程**

**线程可以访问进程的所有共享资源**，但需要注意**同步问题**（多个线程修改同一变量时可能导致竞争条件）。

**子线程**（Subthread）是一个由主线程创建的线程，它与主线程共享同一个进程的内存空间

![image-20250213131122002](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213131122002.png)

![image-20250213131404572](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213131404572.png)

![	](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213131840308.png)

CPU中会设置很寄存器”，用来存放程序运行过程中所需的某些数据

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213132311610.png)



**无论哪个进程控制原语，要做的无非三类事情：**

 **1.更新PCB中的信息修改进程状态(state)**

 **2.将PCB插入合适的队列保存/恢复运行环境** 

**3.分配/回收资源**



## 4.进程通信

进程间通信(Inter-Process Communication,IPC)是指两个进程之间产生数据交互。

为了保证安全，一个进程不能直接访问另一个进程的地址空间。

![image-20250213185013856](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213185013856.png)

### 共享存储

![image-20250213185529887](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213185529887.png)

各个进程对于这个共享存储区的access是**互斥**的 



### 消息传递

直接通信 / 间接通信





![image-20250213190212731](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213190212731.png)

![image-20250213190331589](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213190331589.png)

---





![image-20250213191112067](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213191112067.png)



**管道是流式数据**，只能按照**顺序**读取，不支持随机访问。 （和共享内存通信的区别）

![image-20250213192935220](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213192935220.png)

![image-20250213193042321](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213193042321.png)



## 5.线程

![image-20250213194536141](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213194536141.png)

**这些系统资源不是分配给进程的**

![image-20250213194812056](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213194812056.png)



![image-20250213195028533](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213195028533.png)

## 线程的实现方式和多线程模型

![image-20250213195128796](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213195128796.png)



![image-20250213200546894](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213200546894.png)



![image-20250213200804371](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213200804371.png)

即便是多核处理器但是由于用户级线程的cpu调度单位是进程而不是线程所以这个进程也只能被分配一个cpu

当某个用户线程执行**阻塞型系统调用**（如文件 I/O、网络 I/O、`sleep()`、`read()` 等），**操作系统会将整个进程设置为“等待”状态**。

**由于用户线程共享同一个进程的执行上下文**，如果该进程被阻塞，那么所有用户线程都无法运行。

 **用户级线程的特点**

| 特性             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| **线程管理**     | **由用户态线程库负责**，操作系统**不感知**用户线程的存在     |
| **切换速度**     | **非常快**，因为线程切换**不涉及内核态**，只需在用户态进行   |
| **系统调用影响** | 进程内**某个用户线程被阻塞，整个进程可能都会阻塞**           |
| **内核调度**     | **内核仍然按照进程调度**，不会单独调度用户线程               |
| **跨平台**       | **可以在不支持内核线程的系统上运行**                         |
| **实现库**       | **POSIX Pthreads（用户级实现）、Java 线程、Go 协程、Python 线程（GIL 影响）** |

---

![image-20250213201550666](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213201550666.png)





### 一对一模型

![image-20250213201742198](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213201742198.png)



### 多对一模型

![image-20250213215510426](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213215510426.png)

**多对一模型**，也就是多个用户级线程映射到一个内核级线程。用户级线程是由用户空间的库来管理的，比如早期的POSIX线程库，而内核对此并不知情，内核只能看到那个单独的内核线程。所以当其中一个用户线程执行阻塞操作时，比如I/O操作，由于内核只知道那个内核线程，所以整个内核线程会被阻塞。而因为所有用户线程都依赖于这个唯一的内核线程来执行，所以整个进程的其他用户线程也无法继续运行，导致整个进程阻塞



- 内核级线程是操作系统调度和分配CPU资源的基本单位。
- 用户级线程的所有操作（包括计算、I/O等）最终都需要通过内核级线程来执行。
- 内核级线程为用户级线程提供了**CPU时间片**，使得用户级线程能够在CPU上运行

### 多对多模型

![image-20250213215906295](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213215906295.png)



## 线程的状态和转换



![image-20250213215900766](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213215900766.png)

## 线程的组织和控制

**TCB 这样的数据结构就表示着一个线程 与PCB类似**





![image-20250213220246906](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213220246906.png)



## 6.调度

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。

在操作系统中，调度是管理进程执行的重要机制，主要分为**高级调度**、**中级调度**和**低级调度**。这三种调度各自负责不同层次的任务，具体如下：

**==高级调度==**

**定义**：高级调度（也称作业调度或长程调度）负责从外存（如硬盘）中选择作业，将其加载到内存中并为其分配必要的资源。

**功能与过程**：
- 选择后备队列中的作业，将其调入内存。
- 创建进程控制块（PCB），以便管理进程的状态和资源。
- 决定何时将作业从外存移入内存，通常依据系统的负载和资源可用性。
- 调度频率较低，通常每几分钟进行一次。

**==中级调度==**

**定义**：中级调度（也称内存调度或平衡调度）主要负责在内存和外存之间交换进程，以提高内存利用率和系统吞吐量。

**功能与过程**：
- 将暂时不能运行的进程挂起，并将其移至外存。
- 根据内存的使用情况和进程的状态，决定哪些挂起的进程可以重新调入内存。
- PCB常驻内存，以便于管理和监控进程状态。
- 调度频率中等，可能会在进程状态变化时频繁发生。

**==低级调度==**

**定义**：低级调度（也称进程调度或短程调度）负责在就绪队列中选择一个进程并将CPU分配给它。

**功能与过程**：
- 从就绪队列中选择一个进程，将处理器分配给该进程执行。
- 进行上下文切换，保存当前进程的状态并加载新进程的状态。
- 调度频率高，通常每几秒钟就会发生一次，以确保系统响应及时。



### 高级调度（作业调度）

![image-20250213221344910](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213221344910.png)

**内存**是计算机的临时存储空间，用于存放正在运行的程序和数据。（也就是**进程**的空间）

CPU直接从内存中读取指令和数据 进程的执行依赖于CPU从内存中读取指令并执行

**操作系统**负责管理内存分配、进程调度和CPU资源分配







### 低级调度（进程调度）

![image-20250213223103383](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213223103383.png)







### 中级调度（内存调度）



![image-20250213222558840](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213222558840.png)

---



**在操作系统中，调度分为高级调度、中级调度和低级调度。以下是每种调度的实际例子：**

**高级调度**

**例子**：在一个批处理系统中，用户提交了多个作业（如数据处理、报告生成等）。这些作业首先存储在外存的后备作业队列中。高级调度的任务是从这个队列中选择一些作业，将它们加载到内存中并创建相应的进程。

- **具体过程**：
  - 用户提交作业A、B、C。
  - 操作系统根据设定的策略（如优先级、资源需求等）选择将作业A和B加载到内存中。
  - 为这两个作业创建进程控制块（PCB），并将它们放入就绪队列，准备竞争CPU资源。

中级调度

**例子**：在一个多任务操作系统中，内存资源有限，某些进程可能暂时不能运行。中级调度负责将这些暂时不需要的进程挂起，移至外存，以释放内存给其他需要执行的进程。

- **具体过程**：
  - 进程X正在运行，但由于内存不足，操作系统决定将进程Y挂起并移至外存。
  - 当内存有空闲时，操作系统再将进程Y调入内存，并修改其状态为就绪状态，以便可以再次执行。

低级调度

**例子**：在一个实时操作系统中，多个进程处于就绪状态等待CPU执行。低级调度负责从就绪队列中选择一个进程并将其分配给CPU。

- **具体过程**：
  - 就绪队列中有进程P1、P2和P3。
  - 操作系统使用轮转调度算法，首先选择进程P1分配CPU。
  - 当P1的时间片用完后，操作系统将其挂起，并选择下一个就绪的进程P2继续执行。

通过这三个层次的调度，操作系统能够高效地管理资源，提高系统性能和响应能力。

---

## 7.进程调度的时机、切换、过程与方式

<span style="font-size:1.6em;">**I/O中断的工作原理**</span>

1. **中断请求**：当外部设备完成I/O操作（例如，数据从硬盘读取完成），它会向CPU发送一个中断请求信号。这通常是通过I/O控制器实现的。
2. **CPU响应**：一旦CPU接收到中断信号，它会暂时停止当前正在执行的程序，并保存其状态，以便稍后恢复。
3. **执行中断处理程序**：CPU转向预先定义的中断处理程序，执行相应的代码以处理该I/O操作的结果。例如，它可能会将读取的数据从内存中的缓冲区移动到用户程序指定的位置。
4. **恢复执行**：处理完中断后，CPU会恢复之前被中断的程序，从它停止的地方继续执行

![image-20250213230825635](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213230825635.png)



![image-20250213231331878](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213231331878.png)



![image-20250213231345037](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213231345037.png)

![image-20250213231416527](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213231416527.png)

<span style="font-size:1.9em; font-weight:bold; color:#FF0000;">进程调度的方式</span>

![image-20250213231948719](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213231948719.png)

![image-20250213232531868](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213232531868.png)

![image-20250213232541096](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213232541096.png)

## 8.调度器（调度程序 scheduler）和闲逛（idle）进程

![image-20250215211111802](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215211111802.png)



![image-20250215211205604](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215211205604.png)

CPU（中央处理器）几乎是无时无刻都在运行的。这是因为操作系统和应用程序需要不断地执行指令来完成各种任务，从处理你的输入输出请求到运行应用程序和维护系统的基本功能。即使你的计算机看似闲置，CPU 也会持续地执行一些基本的任务，例如维护系统时钟和处理后台进程。这种持续运行的状态保证了计算机能够随时响应你的操作和需求。

*计组部分知识

**零地址指令**（Zero Address Instruction）是一种计算机指令格式，它不需要显式地指定操作数或操作数的地址（也就是不需要访存）。相比之下，其他指令格式可能需要指定一个或多个操作数的地址或寄存器。零地址指令通常设计用于栈式计算机或者某些指令集体系结构中，其中操作数可以隐含地从栈顶或者特定的寄存器中获取。

在零地址指令中，指令本身包含了足够的信息来执行操作，而不需要额外的操作数地址信息。这种设计简化了指令的格式和编码，同时也能够加快执行速度



![image-20250215211812266](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215211812266.png)

## 9.调度算法的评价指标

![image-20250215211842647](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215211842647.png)

![image-20250215212113827](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215212113827.png)

<span style="font-size:1.5em; color:#FF0000;">**通过课后习题&习题课学习做法**</span>



---

 ![image-20250215212339994](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215212339994.png)

  

周转时间是相对于作业来说的，所以平均周转时间就是平均每个作业的周转时间

**周转时间**  就是提交**（到达）**到完成这个时间  （也就是整个生命周期时间）

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215212850032.png)

![image-20250215213121741](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215213121741.png)

**等待时间**

 ![image-20250215214137062](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215214137062.png)

**响应时间**

![image-20250215214504440](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215214504440.png)





## 10.调度算法

 ![ ](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215214540708.png)

**==作业==提交阶段**：

- 用户提交一个作业（如一个程序任务）给操作系统。
- 作业被放置在**==外存后备队列==**中等待。

**调度阶段**：

- 操作系统从外存后备队列中选择一个作业。
- 选择的标准可能包括作业的优先级、资源需求等。

**进程创建阶段**：

- 选中的作业被加载到内存中，操作系统为其创建一个或多个进程。
- 每个进程被分配到相应的内存空间，并分配执行所需的资源。

**执行阶段**：

- ==进程==被放置在==就绪队列==中，等待处理器的分配。 
- 一旦处理器可用，操作系统会从就绪队列中选择一个进程，将其调度到处理器上执行。

**执行结束及资源释放**：

- 进程执行完毕或者被中断后，操作系统可能将其从处理器移除，并释放相关资源。

- 结束的进程的状态可能会被更新并记录，然后可能将结果返回给用户或者存储到外存

  

  ---

  

  IO中断会唤醒阻塞进程是因为阻塞进程在执行IO操作时需要等待外部设备（如硬盘、网络接口等）完成特定的IO操作，这期间进程无法继续执行其他任务，处于阻塞状态。当外部设备完成IO操作并触发了IO中断时，操作系统会进行以下处理：

  1. **中断处理程序**：
     - 当IO操作完成时，外部设备会发送一个中断信号给CPU。
     - 操作系统会调用与该IO操作相关的中断处理程序（IRQ处理程序），该程序会处理中断并根据中断的类型进行相应的处理。
  2. **唤醒阻塞进程**：
     - 如果阻塞进程是因为等待某个IO操作而阻塞的，中断处理程序会根据进程的状态将其从阻塞状态转换为就绪状态（Ready）。
     - 这意味着操作系统认为进程现在可以继续执行，因为所需的IO操作已经完成。
  3. **状态转换**：
     - 一旦进程被唤醒并放入就绪队列，操作系统的调度程序会在适当的时候将其调度到CPU上执行。
     - 进程在恢复执行后可以继续处理IO操作的结果或者执行接下来的任务。

## 先来先服务：

 ![image-20250215223930398](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215223930398.png)



![image-20250215224051211](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215224051211.png)

注意非抢占式调度算法：

非抢占式调度算法通常通过进程主动放弃CPU或者在IO等待时让出CPU，而不会被操作系统强制剥夺CPU资源。

这种调度方式可以带来一定程度的**同步效果**，因为**进程的执行是有序的，一个进程执行完毕或者等待IO时，另一个进程才能开始执行。**

## 短作业优先：

![image-20250215225441511](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215225441511.png)

---



![image-20250215232540150](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215232540150.png)

  

![image-20250215233228600](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215233228600.png)

![image-20250215233347077](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215233347077.png)

## 高响应比优先算法：

![image-20250215233911055](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215233911055.png)

![image-20250215234020808](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215234020808.png)

![image-20250215234017984](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215234017984.png)

![image-20250215234043955](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215234043955.png)

## 时间片轮转调度算法（RR）![image-20250225190744420](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225190744420.png)

![image-20250225190812960](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225190812960.png)

![image-20250225190954170](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225190954170.png)

![image-20250225190829203](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225190829203.png)

![image-20250225190843416](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225190843416.png)

![image-20250225191009295](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191009295.png)

## 优先级调度算法

### 非抢占式

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191028644.png)

### 抢占式

![image-20250225191050991](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191050991.png)

![image-20250225191123342](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191123342.png)



![image-20250225191145238](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191145238.png)

## 多级反馈调度算法





![image-20250225191213150](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191213150.png)



![image-20250225191220309](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191220309.png)



![image-20250225191227299](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191227299.png)

![image-20250225191316466](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191316466.png)



## 多级队列调度算法

![image-20250225191435938](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191435938.png)



**多级队列调度**
将进程分成多个固定队列，每个队列对应一个优先级。
队列中的进程优先级是静态的，不会在不同队列间移动。
调度器按照优先级顺序调度队列中的进程，高优先级队列中的进程先被调度。



**多级反馈队列调度**
允许进程在不同队列之间移动，优先级是动态调整的。
一个进程执行完一个时间片后，如果没有完成任务，会被移动到低优先级的队列中。
通过降低长时间运行进程的优先级，实现更加公平的资源分配和防止某些进程长期占用CPU资源。

## 11.同步与互斥

### 基本概念

![image-20250225192047716](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225192047716.png)

![image-20250225204331799](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225204331799.png)

**实现互斥访问的==四个原则==**

![image-20250225204338361](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225204338361.png)





### 进程互斥的软件实现方法

#### 单标志法

**最大问题：违反“空闲让进的问题”**

**要是a一直不使用他也不会让所以b就一直进不去**

![image-20250225205242025](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225205242025.png)

#### 双标志先检查

![image-20250226215720162](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250226215720162.png)

![image-20250226215736656](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250226215736656.png)

#### 双标志后检查

![image-20250226215742324](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250226215742324.png)

#### Peterson 算法

![image-20250226215748089](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250226215748089.png)



![image-20250226215812192](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250226215812192.png)



![image-20250226215846116](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250226215846116.png)

### 进程互斥的硬件（一气呵成，执行过程不允许中断）实现方法

![image-20250302192224745](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302192224745.png)

#### 中断屏蔽方法

![image-20250302192254658](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302192254658.png)

为什么多核系统不适用：

**单核环境下**：关闭中断后，该核心不会被其他中断抢占，能确保临界区的独占执行。

**多核环境下**：中断屏蔽仅作用于当前核心，其他核心仍然可以响应中断并访问共享资源。例如：

- 核心A屏蔽中断后进入临界区，但核心B未屏蔽中断，仍可能通过中断或直接访问同一共享资源，导致数据竞争。

#### TestAndSet指令

![image-20250302192645556](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302192645556.png)

没锁上 lock = false 返回false 设置lock = true 上锁 

锁上 lock = true 返回 true 一直死循环判断 

#### Swap指令

![image-20250302192855185](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302192855185.png)

![image-20250302193503636](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302193503636.png)



### 互斥锁

![image-20250302193521248](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302193521248.png)

**原子操作--> 硬件机制**

**缺点也是违反了 “让权等待”**

![image-20250302193649084](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302193649084.png)



### 信号量机制 (PV大题)

![image-20250302193743092](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302193743092.png)





![image-20250302193800582](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302193800582.png)



#### 整型信号量

![image-20250302193923294](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302193923294.png)

**1.原子操作:**信号量的 wait 和signal操作是原子的。这意味着这些操作要么完全执行，要么完全不执行，避免了竞态条件。操作系统在实现这些操作时通常会使用硬件提供的原子指令来确保操作的不可分割性，

**2.硬件支持:**现代处理器提供了各种原子指令(如 compare-and-swap 或test-and-set)来支持同步原语的实现。这些指令可以确保在多处理器环境下，同时只有一个处理器能修改信号量的值，从而避免了并发修改的问题。

**3.锁机制:**在信号量的实现中，通常会使用底层的锁来保证对信号量计数值的修改是互斥的。这样，当一个线程在进行 wait 或 signal操作时，其他线程会被阻塞，直到当前操作完成。



---



#### 记录型信号量（使用某种数据结构存储数据）

![image-20250302194226962](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302194226962.png)



![image-20250302194443467](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302194443467.png)

![image-20250302194451178](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302194451178.png)

![image-20250302194458052](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302194458052.png)

**阻塞：block 运行态-> 阻塞态**

**唤醒：wakeUp  阻塞态->运行态**



---



**先理解逻辑块 再分析代码部分  形成有效的思维链**

![image-20250302194505608](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302194505608.png)

### 用信号量实现进程互斥、同步、前驱关系

![image-20250302194714006](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302194714006.png)



**就是利用互斥信号量** mute





---



![image-20250302194752850](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302194752850.png)

**同步:要求进程严格按一定顺序执行**

**前（操作）V 后（操作）P**

---



![image-20250302194744178](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302194744178.png)



### 生产者-消费者问题

分析进程的同步、互斥关系

PV操作

==选定互斥、同步信号量==



![image-20250302194740205](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302194740205.png)



**P(S)一一申请一个资源S,如果资源不够就==阻塞等待==** 

**V(s)一一释放一个资源S,如果==有进程==在==等待==该资源，则==唤醒一个进程==**

---



**交换顺序--> 循环等待 --> 死锁**



![image-20250302195547516](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302195547516.png)



**注意：**

使用产品可以放到pv操作之间 ，但是这样会导致临界区代码变长 导致一个进程对临界区上锁的时间增加，这样肯定不利于各个进程









---



![image-20250302195258324](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302195258324.png)

### 多生产者-多消费者问题

![image-20250302195229988](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302195229988.png)



![image-20250302195241055](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302195241055.png)

但如果缓冲区大了就不行

![image-20250302195824094](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302195824094.png)

![image-20250302195846343](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302195846343.png)



![image-20250302195855119](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302195855119.png)

![image-20250302195909529](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302195909529.png)





### 吸烟者问题

![image-20250302195946293](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302195946293.png)





![image-20250302195932268](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302195932268.png)

![image-20250302200159166](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302200159166.png)



![image-20250302200205492](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302200205492.png)



### 读者-写者问题

![image-20250302200208825](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302200208825.png)

![image-20250302200305610](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302200305610.png)

![image-20250302200310881](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302200310881.png)

![image-20250302200329514](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302200329514.png)



![image-20250302200318517](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302200318517.png)







### 哲学家进餐问题

![image-20250302200353218](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302200353218.png)

**出现死锁的情况**



![image-20250302200405731](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302200405731.png)



![image-20250302200437667](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302200437667.png)

**第三个方案：仅当一个哲学家左右两边筷子都可以用的时候才允许他抓起筷子**





![image-20250302200446539](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302200446539.png)



### 管程

#### 为什么要引入管程这个概念

![image-20250302201114350](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201114350.png)

#### 管程的定义和基本特征



 ![image-20250302201126923](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201126923.png)

#### 管程的应用场景

![image-20250302201214243](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201214243.png)

![image-20250302201218076](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201218076.png)

#### java与管程

![image-20250302201251045](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201251045.png)



### 死锁

![image-20250302201312448](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201312448.png)

#### 死锁产生的四个必要条件



![image-20250302201317248](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201317248.png)



![image-20250302201326238](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201326238.png)



---



![image-20250302201328655](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201328655.png)

### 死锁的处理策略

#### 预防死锁

##### 破坏互斥条件



![image-20250302201432886](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201432886.png)

##### 破坏不剥夺条件



![image-20250302201441747](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201441747.png)

##### 破坏请求和保持条件

![image-20250302201449199](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201449199.png)

##### 破坏循环等待条件



![image-20250302201458357](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201458357.png)



**这些缺点实际场景是什么呢 不要光死记硬背要理解性记忆**

---



![image-20250302201503760](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201503760.png)

**mission：哲学家问题三个方案分别是破坏了哪三个死锁的必要条件**



#### 避免死锁

![image-20250302201746447](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201746447.png)

##### 银行家算法



![image-20250302201821207](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201821207.png)

![image-20250302201846047](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201846047.png)

![image-20250302201900989](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201900989.png)

![image-20250302201922260](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201922260.png)



---



![image-20250302201929984](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201929984.png)

#### 检测和解除

![image-20250302201952055](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302201952055.png)

![image-20250302202011080](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202011080.png)

![image-20250302202018502](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202018502.png)

![image-20250302202051634](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202051634.png)

![image-20250302202122144](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202122144.png)



![image-20250302202205306](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202205306.png)





![image-20250302202212080](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202212080.png)



 **recollect ：**<span style="font-size:1.7em; font-weight:bold; color:#FF0000;">进程的分类</span>

<span style="font-size:1.7em; font-weight:bold; color:#FF0000;"> **一、按运行特性与调度需求分类**</span>

1. **批处理进程（Batch Process）**

- **定义**：无需用户交互，按预定任务队列批量执行的进程。
- **特点**：
  - 以作业（Job）为单位提交，顺序执行。
  - 通常处理大量计算或数据处理任务（如科学计算、日志分析）。
  - 优先级较低，注重吞吐量而非实时性。
- **例子**：银行对账系统、批量图像渲染。

2. **交互式进程（Interactive Process）**

- **定义**：依赖用户输入并实时响应的进程。
- **特点**：
  - 需要频繁的I/O操作（键盘、鼠标、屏幕输出）。
  - 响应时间短（通常 < 1秒），优先级较高。
- **例子**：文本编辑器、命令行终端、图形界面应用。

3. **实时进程（Real-Time Process）**

- **定义**：必须在严格时间限制内完成任务的进程。
- **特点**：
  - 分为**硬实时**（绝对不可错过截止时间，如火箭控制）和**软实时**（允许偶尔延迟，如流媒体）。
  - 优先级最高，抢占其他进程资源。
- **例子**：工业机器人控制、自动驾驶系统、音视频实时编码。



---



<span style="font-size:1.7em; font-weight:bold; color:#FF0000;">**二、按功能角色分类**</span>

4. **守护进程（Daemon Process）**

- **定义**：后台长期运行的服务进程，通常无用户界面。
- **特点**：
  - 随系统启动而运行，响应特定事件或请求。
  - 资源占用低，生命周期长。
- **例子**：Web服务器（Nginx）、数据库服务（MySQL）、系统监控工具（Prometheus）。

5. **系统进程 vs 用户进程**

- **系统进程**：
  - 由操作系统内核直接管理，执行底层任务（如内存管理、进程调度）。
  - 例子：`systemd`（Linux初始化进程）、`kswapd`（内存交换守护进程）。
- **用户进程**：
  - 由用户启动，运行应用程序（如浏览器、办公软件）。



---



**<span style="font-size:1.7em; font-weight:bold; color:#FF0000;">三、按调度优先级与交互模式分类</span>**

6. **前台进程（Foreground Process）**

- **定义**：占用终端或用户界面，直接与用户交互。
- **特点**：
  - 优先级高，需即时响应用户操作。
  - 执行期间会阻塞终端输入（如编译任务在前台运行时无法输入其他命令）。

7. **后台进程（Background Process）**

- **定义**：脱离终端或界面在后台运行。
- **特点**：
  - 通过`&`符号启动（如`python script.py &`）。
  - 用户可继续执行其他任务，但可能受资源竞争影响。



---

# 第三章

## 1.内存的基础知识

![image-20250302202718234](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202718234.png)

![image-20250302202734642](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202734642.png)

---

**指令的工作原理**



![image-20250302202803179](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202803179.png)



![image-20250302202810385](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202810385.png)

![image-20250302202817426](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202817426.png)





**单道程序环境(single-tasking environment)**

是指计算机系统中**一次只能执行一个程序**的操作环境。在这种环境下，系统资源(如处理器、内存等)完全专用于当前运行的程序，直到程序执行完毕或被终止后，才会切换到另一个程序执行。这种环境通常用于早期计算机系统和某些嵌入式系统中。虽然单道程序环境简单，但在现代多任务操作系统中已不常见，因为它无法充分利用现代计算机的多核处理能力和资源共享功能。



#### 装入的三种方式

##### 绝对装入：



![image-20250302202931960](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202931960.png)





##### 可重定位装入

![image-20250302202939467](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202939467.png)

##### 动态重定位



![image-20250302202946958](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202946958.png)





----



![image-20250302202951320](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302202951320.png)

**静态链接:**

**过程:**在编译阶段，所有需要的库文件和外部函数代码都会被链接器打包到可执行文件中。这样生成的可执行文件是自包含的.不需要依赖外部的库文件

**优点:**运行时不需要额外的库文件，因此避免了找不到库文件的问题，并且加载速度较快。

**缺点**:生成的可执行文件较大，并且更新库文件时需要重新编译整个程序。

---



**装入时动态链接(Load-timedynamic linking):**

**链接时间:**在程序启动时进行链接。操作系统会在加载可执行文件时，寻找并加载所需的动态链接库(DLL)过程:当程序启动时，操作系统会加载所有需要的DLL，并将外部函数的地址绑定到程序中。这意味着在程序开始运行之前，所有的链接和加载操作已经完成。

**优点:**程序启动后，不需要再进行动态加载，减少了运行时的开销。
**缺点:**如果程序依赖的某个DLL缺失或版本不兼容，程序可能无法启动

---



**运行时动态链接(Run-time dynamiclinking)**

**链接时间:**在程序运行过程中(根据需要动态加载库文件和链接外部函数。
过程:程序在运行时可以根据需要调用特定函数来加载DLL(例如LoadLibrary函数)，并使用函数指针来调用DLL中的函数。这种方式使得程序可以在运行时灵活地加载和卸载DLL。
**优点:**可以按需加载DLL，减少初始启动时的开销，提高程序的灵活性。只有在需要时才加载相应的DLL，有助于节省内存。

**缺点:**运行时需要额外的管理代码，处理加载和卸载DLL的操作。如果加载过程出错，可能会导致程序在运行中断。

---



#### 链接的三种方式







![image-20250302203238023](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302203238023.png)

![image-20250302203245535](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302203245535.png)

## 内存管理的概念

#### 内存空间的扩展

![image-20250302203251275](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302203251275.png)

#### 地址转换

![image-20250302203425806](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302203425806.png)

![image-20250302203433508](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302203433508.png)

#### 内存保护

![image-20250302203436540](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302203436540.png)

![image-20250302203500077](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302203500077.png)



---



![image-20250302203456766](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250302203456766.png)



---

### 内存空间的扩充





![image-20250312201656300](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312201656300.png)

#### 覆盖技术

![image-20250312203339735](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312203339735.png)

![image-20250312203350663](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312203350663.png)





#### 交换技术

![image-20250312203402621](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312203402621.png)



![image-20250312203409121](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312203409121.png)

![image-20250312203417513](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312203417513.png)



#### 虚拟存储技术

**见下文**



## 内存分配

![image-20250312203438142](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312203438142.png)



### 连续分配管理方式

#### 单一连续分配

![image-20250312203723736](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312203723736.png)



#### 固定分区分配

![image-20250312203739181](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312203739181.png)

![image-20250312203726648](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312203726648.png)

#### 动态分区分配

![image-20250312203743983](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312203743983.png)

![1741783070920](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741783070920.png)

![1741783075102](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741783075102.png)



![1741783088287](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741783088287.png)

![image-20250312214217679](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312214217679.png)

![1741783101961](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741783101961.png)

![1741783107206](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741783107206.png)

![1741783111632](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741783111632.png)

![1741783120475](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741783120475.png)

![1741783126185](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741783126185.png)





### 动态分区分配算法

![image-20250312210257460](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312210257460.png)

### 首次适应算法

![image-20250312210743173](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312210743173.png)

![1741784628847](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741784628847.png)



### 最佳适应算法

![image-20250312210758067](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312210758067.png)

![1741784638943](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741784638943.png)



![image-20250312210830824](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312210830824.png)

### 最坏适应算法

![image-20250312210828149](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312210828149.png)

### 邻近适应算法

![image-20250312210849239](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312210849239.png)



![image-20250312210852293](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312210852293.png)



## 非连续分配

![image-20250312210904789](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312210904789.png)

## 基本分页存储管理的概念

![image-20250312211224161](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312211224161.png)

![image-20250312211226195](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312211226195.png)

![image-20250312211246414](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312211246414.png)

![image-20250312211301108](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312211301108.png)

![image-20250312211326574](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312211326574.png)



![image-20250312211336518](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312211336518.png)

![image-20250312211356932](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312211356932.png)

![image-20250312211411857](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312211411857.png)

![1741785261838](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785261838.png)

![1741785265736](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785265736.png)

![1741785271170](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785271170.png)

![1741785275079](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785275079.png)

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785275079.png)

![1741785283157](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785283157.png)



## 基本地址变换机构

![1741785313354](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785313354.png)

![1741785318317](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785318317.png)

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785318317.png)

![1741785327933](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785327933.png)

![1741785331852](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785331852.png)

![1741785336244](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785336244.png)

![1741785339886](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785339886.png)



## 具有块表的地址变换机构

![1741785389626](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785389626.png)

![1741785386026](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785386026.png)

当这个进程上处理机运行时，系统会清空快表的内容，当进程切换的时候，快表是一个硬件，**块表的内容也需要被清除**





![1741785382073](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785382073.png)

![1741785368274](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785368274.png)

![1741785362020](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785362020.png)



![1741785524515](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785524515.png)

![1741785527643](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785527643.png)





## 两级页表

![1741786084377](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786084377.png)

![1741786088050](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786088050.png)

![147f69a067e24b17611c80822c7d274](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/147f69a067e24b17611c80822c7d274.jpg)

![1741786093984](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786093984.png)

![1741785561443](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785561443.png)

![1741785565095](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785565095.png)

![1741785569744](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785569744.png)

![1741785572859](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785572859.png)

![1741785576509](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785576509.png)

![1741785579604](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785579604.png)











## 基本分段存储管理方式

![1741785603696](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785603696.png)

![1741785606339](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785606339.png)

![1741785609725](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785609725.png)

![1741785614620](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785614620.png)

![1741785617763](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785617763.png)

![1741785621674](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785621674.png)

![1741785625309](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785625309.png)



**分页(一维地址空间)**
分页机制中的，程序员只需要提供一个记忆符(通常是一个线性地址)，操作系统会负责将这个线性地址映射到物理内存地址。这里的用户地址空间看起来是一个连续的内存区域，但实际上可能分布在不同的物理内存页中。
例子: 假设程序员需要访问内存地址0x1234，这个地址是线性的。操作系统通过页表将0x1234映射到实际的物理内存地址，例如OxABCD。

---



**分段(二维地址空间)**
在分段机制中，用户进程地址空间是二维的。这意味着程序员在引用内存地址时不仅需要提供段名，还需要提供段内地址。每个段表示一个独立的内存区域，可能包含特定类型的数据，例如代码段、数据段和堆栈段。



**进程和段表的关系：**

进程和段表在操作系统中有着密切的关系。进程是程序在系统中的一次执行活动，它包含了程序计数器、寄存器、堆栈、数据段等。而段表是操作系统用来管理段式内存的一种数据结构。
段表记录了进程的每一个段的信息，包括段的起始地址、段的长度、段的权限等。它帮助操作系统将进程的逻辑地址转换成物理地址，以便对内存进行有效管理。每个进程都有一个独立的段表，通过段表，操作系统可以实现内存保护和共享，提高内存利用率。
可以将段表看作是进程的内存地图，帮助操作系统跟踪和管理进程所使用的各个内存段。因此，段表对于进程的内存管理至关重要。

---





![1741785745463](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785745463.png)

![1741785748060](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785748060.png)

![1741785750395](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785750395.png)

![1741785753797](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785753797.png)



## 段页式管理方式

![1741785765729](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785765729.png)

![image-20250312212930533](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312212930533.png)

![1741785771709](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785771709.png)

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785774797.png)

![image-20250312213701134](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312213701134.png)

![1741785780471](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785780471.png)

![1741785785426](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785785426.png)

![image-20250312212946408](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312212946408.png)

![1741785793734](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785793734.png)

![1741785797112](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785797112.png)

![1741785800508](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785800508.png)



## 虚拟内存的基本概念

![image-20250312212551719](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312212551719.png)

![image-20250312212556066](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312212556066.png)



![1741785842349](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785842349.png)

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785844702.png)

![1741785850171](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785850171.png)

![image-20250312213124242](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312213124242.png)

## 请求分页管理方式

![image-20250312213137683](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312213137683.png)

![1741785871762](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785871762.png)

![1741785874395](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785874395.png)

![image-20250312213159248](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312213159248.png)

![1741785877000](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785877000.png)

![image-20250312213223030](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312213223030.png)

![1741785882473](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785882473.png)

![1741785885325](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785885325.png)

![1741785888956](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785888956.png)

![image-20250312213300881](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312213300881.png)

![image-20250312213321861](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312213321861.png)

![1741785904509](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741785904509.png)

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312213326805.png)

## 页面置换算法

![1741786418463](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786418463.png)

![1741786421620](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786421620.png)

![1741786423962](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786423962.png)

![1741786430657](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786430657.png)

![1741786434303](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786434303.png)

![1741786438477](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786438477.png)

![1741786442118](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786442118.png)

![1741786446304](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786446304.png)

![1741786448891](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786448891.png)

## 页面分配策略

![1741786687618](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786687618.png)

![1741786691783](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786691783.png)

![1741786694342](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786694342.png)

![1741786696958](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786696958.png)

![1741786698999](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786698999.png)

![1741786701609](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786701609.png)

![1741786703950](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786703950.png)

![1741786706252](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786706252.png)

![1741786755678](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786755678.png)

![1741786758282](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786758282.png)

![1741786762478](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741786762478.png)

## 内存映射文件

![image-20250312213559335](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312213559335.png)

# 第四章

![image-20250305210315310](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305210315310.png)

![image-20250305210350578](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305210350578.png)

==无结构==与==有结构==文件的例子：

![image-20250305210439945](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305210439945.png)

**文件内部如何组织的问题** ---- ==逻辑结构==





![image-20250305210613801](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305210613801.png)

**详情见后面的==文件操作==：**



![image-20250305211159110](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305211159110.png)





以==块==（磁盘块/物理块）为单位

![image-20250305211258412](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305211258412.png)

**文件管理的初识：**







![image-20250305211249217](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305211249217.png)



## 文件的逻辑结构



![image-20250305211649490](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305211649490.png)

### 有结构文件

**定长记录和不定长记录**

​	![image-20250305211730369](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305211730369.png)

---



![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305211759509.png)

无结构文件就是**流式文件**



### 有结构文件的逻辑结构

![image-20250305211841160](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305211841160.png)

#### 顺序文件

![image-20250305212044164](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212044164.png)



![image-20250305212055094](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212055094.png)



#### 索引文件

![image-20250305212101926](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212101926.png)

#### 索引顺序文件

![image-20250305212124463](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212124463.png)

**效率分析：**

![image-20250305212128488](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212128488.png)

**套娃继续（经典优化）多级方法**

![image-20250305212133569](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212133569.png)

**总结：**



![image-20250305212135873](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212135873.png)

![image-20250305212257911](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212257911.png)

## 文件目录和文件控制块（FCB）

**注意联系进程控制块** （PCB）

![image-20250305212331276](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212331276.png)

目录对应一个目录文件 目录文件中存放着一条一条的FCB （一个文件目录项就是对应一个FCB）

**重点：FCB的组成**



![image-20250305212340000](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212340000.png)

### 目录结构

#### 单级目录结构

![image-20250305212608832](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212608832.png)

#### 两级目录结构

![image-20250305212623516](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212623516.png)

#### 多级(树形)目录结构

![image-20250305212701620](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212701620.png)

---



![image-20250305212722417](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212722417.png)







#### 无环图目录结构



![image-20250305212738441](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212738441.png)

### 索引结点

![image-20250305212918539](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212918539.png)

![image-20250305212914161](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212914161.png)

![image-20250305212936839](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305212936839.png)





---

## 文件的物理结构（文件的分配方式）



![image-20250305213020942](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305213020942.png)

**就是如何放在外存当中！**

![image-20250305213049706](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305213049706.png)

### 文件块、磁盘块

![image-20250305213228264](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305213228264.png)



​	![image-20250305213255263](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305213255263.png)





### 连续分配

![image-20250305213506745](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305213506745.png)



![image-20250305213432345](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305213432345.png)



![image-20250305213436444](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305213436444.png)





![image-20250305213624833](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305213624833.png)



### 链接分配



#### 隐式链接

![image-20250305213741882](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305213741882.png)



![image-20250305213746100](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305213746100.png)







#### 显式链接

![image-20250305213811490](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305213811490.png)



![image-20250305213858779](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305213858779.png)

**随机访问的体现：**就是可以通过内存中的这个FAT表直接找到要访问的块号， 然后再去外存中去找块号的物理地址 这样就是==随机访问==了

---





![image-20250305213904437](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305213904437.png)

### 索引分配

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305214536743.png)

**问题：论为什么可以隐含逻辑块号呢？**

因为这个索引表的表项每一行都是==一样==的是占**四个字节** 只要我们知道这个索引表的起始位置 又因为这种表一般都是顺序存储的 所以可以直接计算出是哪个逻辑块号 这样就知道物理块号



![image-20250305215036984](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215036984.png)



![image-20250305215048733](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215048733.png)



![image-20250305215102598](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215102598.png)

![image-20250305215112944](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215112944.png)

![image-20250305215126720](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215126720.png)

**这个还是存在一点问题：**

就是一个文件很小（1KB） 但是使用这个两层索引 那么读入这个1KB文件都要三次读磁盘的操作 大大增加了开销







![image-20250305215347086](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215347086.png)

​	





**总结：**
![image-20250305215402624](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215402624.png)

---



![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215410590.png)



---

## 文件的逻辑结构和物理结构



![image-20250305215455421](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215455421.png)



### 无结构文件的逻辑/物理结构





![image-20250305215503253](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215503253.png)



![image-20250305215528400](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215528400.png)

![image-20250305215549120](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215549120.png)

![image-20250305215607909](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215607909.png)

### 顺序文件（顺序存储的物理结构）





![image-20250305215625003](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305215625003.png)





![image-20250305222852941](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305222852941.png)

![image-20250305222916307](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305222916307.png)



![image-20250305222922213](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305222922213.png)



---





![image-20250305222121693](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305222121693.png)



### 顺序文件（链式存储的物理结构）









![image-20250305222124361](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305222124361.png)

![image-20250305222128874](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305222128874.png)

---



### 索引文件的物理结构



![image-20250305223545623](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305223545623.png)

![image-20250305223515617](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305223515617.png)

![image-20250305223703822](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305223703822.png)

---



## 文件存储空间的管理





​		![image-20250305223727762](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305223727762.png)

![image-20250305223751093](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305223751093.png)





### 空闲表法

![image-20250305223852848](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305223852848.png)



![image-20250305223900059](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305223900059.png)



![image-20250305223908051](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305223908051.png)



![image-20250305223914749](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305223914749.png)



---



### 空闲链表法

![image-20250305224007731](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224007731.png)

![image-20250305224014519](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224014519.png)

![image-20250305224020474](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224020474.png)

---



### 位示图法

![image-20250305224049792](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224049792.png)

![image-20250305224047472](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224047472.png)

### 成组链接法

![image-20250305224113343](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224113343.png)

![image-20250305224128285](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224128285.png)

由于此时超级块已经读入内存了，所以在进行这个检查的操作的时候不需要去读磁盘操作，只需要找到内存当中这些超级块的数据检查即可



![image-20250305224223747](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224223747.png)

**作为这个分组的第一个磁盘块，还需要记录下一组空闲盘块的一些信息**！！！！

![image-20250305224231148](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224231148.png)



**回收：**

![image-20250305224620995](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224620995.png)



![image-20250305224732155](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224732155.png)





---





![image-20250305224744112](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224744112.png)

![image-20250305224749744](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224749744.png)

![image-20250305224801747](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224801747.png)

![image-20250305224806106](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224806106.png)



## 文件的基本操作

### 创建文件



![image-20250305224843747](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224843747.png)

### 删除文件



![image-20250305224849413](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224849413.png)

### 打开文件



![image-20250305224851701](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224851701.png)

![image-20250305224859507](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224859507.png)

### 关闭文件



![image-20250305224933460](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224933460.png)

### 读文件



![image-20250305224937386](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224937386.png)

### 写文件



![image-20250305224942060](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224942060.png)

**总结：**

![image-20250305224946058](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305224946058.png)

## 文件共享

![1741186265024](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186265024.png)

![1741186268697](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186268697.png)

![1741186271825](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186271825.png)

![1741186278075](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186278075.png)

![1741186280933](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186280933.png)

**总结：**

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186284589.png)

## 文件保护

![1741186390794](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186390794.png)

### 口令保护



![1741186394954](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186394954.png)

### 加密保护



![1741186398878](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186398878.png)

### 访问控制



![1741186402750](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186402750.png)

![1741186406155](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186406155.png)

![1741186419965](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186419965.png)

![1741186423347](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186423347.png)

**总结：**

![1741186426229](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186426229.png)



## 文件系统以及文件系统的层次结构

![image-20250305225441349](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305225441349.png)

![image-20250305225443710](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305225443710.png)

## 文件系统布局

### 物理格式化

![1741186551749](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186551749.png)

### 逻辑格式化



![image-20250305225724116](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250305225724116.png)

### 文件系统在外存中的结构

![1741186559874](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186559874.png)

### 文件系统在内存中的结构

![1741186564055](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186564055.png)

![1741186566906](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741186566906.png)



## 虚拟文件系统

![image-20250312184121026](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312184121026.png)



![image-20250312184134034](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312184134034.png)

![image-20250312184148090](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312184148090.png)

![image-20250312184155481](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312184155481.png)



然后会把文件的inode从外存先读入主存，然后读入的inode的信息会被复制到vnode中

![image-20250312184345066](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312184345066.png)

![image-20250312184339332](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312184339332.png)

那么这个u盘的这个文件系统就需要挂载到操作系统上

具体就是要挂载到操作系统的虚拟文件系统

**挂载点**其实就是一个目录，当**一个目录为挂载点**时，该目录就是对应文件系统的**入口**了



# 第五章

## IO设备的基本概念和分类



![1741776533631](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776533631.png)

![1741776536786](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776536786.png)

![1741776540143](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776540143.png)

![1741776543007](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776543007.png)

![1741776546648](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776546648.png)

---

## IO控制器

![1741776622005](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776622005.png)

![1741776625366](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776625366.png)

![1741776629044](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776629044.png)

![1741776632688](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776632688.png)

![1741776641264](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776641264.png)

![1741776644361](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776644361.png)

![1741776647701](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776647701.png)

---

## IO控制方式

![1741776768203](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776768203.png)

### 程序直接控制方式

![1741776772602](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776772602.png)

![1741776777273](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776777273.png)

![1741776784269](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776784269.png)

### 中断驱动方式



![1741776787638](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776787638.png)

![1741776791018](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776791018.png)

### DMA方式



![1741776793897](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741776793897.png)

![image-20250312185510800](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312185510800.png)

只有到DMA完成的整个CPU指定的一系列任务后，它才会向CPU发送一个中断信号，然后CPU再介入进行后序的处理

DMA控制器在读入数据的过程中也是一个字一个字的读入的，然后每次读入的字都是放到DR，最终就可以完成一整块的数据读入操作

（一个字一个字地读入DR，读满一块再交换  ，一块数据全读完才会通知吧，之前读一个字就需要通知）

![image-20250312190010145](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312190010145.png)

### 通道控制方式





![1741777214768](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777214768.png)

![1741777217657](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777217657.png)

![1741777220233](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777220233.png)



## IO软件的层次



![1741777223641](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777223641.png)

### 用户层软件





![1741777375485](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777375485.png)

### 设备独立性软件

![1741777378814](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777378814.png)

![1741777381668](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777381668.png)

![image-20250312190618938](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312190618938.png)

![1741777393871](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777393871.png)

![1741777398811](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777398811.png)

![1741777401693](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777401693.png)

![1741777404810](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777404810.png)

### 设备驱动程序



![image-20250312190705580](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312190705580.png)

![1741777412064](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777412064.png)

### 中断处理程序



![image-20250312190736519](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312190736519.png)

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312190736519.png)

## 输入输出管理



![image-20250312190741206](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312190741206.png)

### IO应用程序接口



![1741777716214](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312190939902.png)

![1741777720122](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777720122.png)

![1741777740368](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741777740368.png)

**中断处理程序发现 中断信号是来源于网络控制器**

### 阻塞/非阻塞IO

**阻塞 I/O（Blocking I/O）**

**特点：**

- 进程（线程）在执行 I/O 操作时，如果数据没有准备好，会一直等待，直到 I/O 操作完成后才返回。
- 期间进程会被挂起，操作系统会调度其他进程执行，直到 I/O 操作完成后，该进程才会被重新调度执行。

---





![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312191359477.png)

想要把这块数据写到磁盘的时候，

即使磁盘此时正处于忙碌当中，那设备独立性软件那一层也会快速响应这个系统调用请求，先把你这个数据先复制到内核，那接下来内核就慢慢地把这个数据写回磁盘，只要完成了这个数据复制的过程，就可以让你继续往下执行了。









---



### 设备驱动程序接口

**设备独立的系统调用标准在同一个操作系统中是否一致?**

同一个操作系统通常提供设备独立的标准接口来对外暴露统一的操作方法，这种抽象让应用程序不需要直接与硬件打交道。例如:
文件系统操作:无论是读取硬盘、U盘还是网络存储设备，调用方式在应用程序层面可能只是一个统一的
read()或write()。

尽管**接口标准一致**，但某些地方可能因设备差异而有所不同:

**底层驱动的实现方式不同:**

比如硬盘的读写和网络存储设备O的读写虽然在调用层面是一致的，但驱动程序实现上会根据硬件差异而有所不同。
某些设备可能具有专属功能，这些功能需要额外的控制命令

**硬件支持的特性不同:**

例如，同为打印机，不同型号可能支持的分辨率、颜色调整方式不同，驱动程序需要在具体实现中处理这些设备特性。

**性能优化或设备限制:**
某些硬件驱动程序可能针对特定硬件进行优化，而无法在其他设备上达到一致的行为或性能表现。





---- 类似与多态



![1741778070150](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741778070150.png)

![1741778074042](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741778074042.png)

![1741778078972](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741778078972.png)



## IO核心子系统

![image-20250312192755117](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312192755117.png)

### IO调度



![image-20250312192815621](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312192815621.png)

### 设备保护



![image-20250312192831938](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312192831938.png)

### 假脱机技术



![image-20250312192827831](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312192827831.png)

![image-20250312192933581](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312192933581.png)

![image-20250312192937204](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312192937204.png)

![image-20250312192940387](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312192940387.png)

![image-20250312192951901](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312192951901.png)

![image-20250312193014775](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193014775.png)

![image-20250312193018606](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193018606.png)

![image-20250312193023017](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193023017.png)

![image-20250312193028807](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193028807.png)

---



## 设备的分配和回收

![image-20250312193140000](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193140000.png)

![1741779060963](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779060963.png)

![1741779065376](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779065376.png)

![1741779072986](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779072986.png)

### 静态分配和动态分配

![1741779131715](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779131715.png)

### 设备分配管理中的数据结构

![1741779135348](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779135348.png)

![1741779144187](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779144187.png)

![1741779147572](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779147572.png)

![1741779150433](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779150433.png)

![1741779153841](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779153841.png)

![1741779157448](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779157448.png)

### 设备分配的步骤

![1741779160573](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779160573.png)

![1741779164236](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779164236.png)

![1741779167630](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779167630.png)

### 设备分配步骤的改进



![image-20250312193328358](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193328358.png)

![image-20250312193331211](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193331211.png)

![image-20250312193335491](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193335491.png)

![image-20250312193338946](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193338946.png)



## 缓冲区的管理

### 缓冲区的作用



![image-20250312193515719](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193515719.png)



![1741779416861](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779416861.png)

### 单缓冲



![1741779429265](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779429265.png)

![1741779434454](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779434454.png)

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779445389.png)

![1741779445389](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779445389.png)

![1741779450340](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779450340.png)





### 双缓冲



![image-20250312193918867](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193918867.png)

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193908056.png)

![image-20250312193928354](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193928354.png)

### 使用单/双缓冲在通信时的区别

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193952260.png)





![image-20250312193942651](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193942651.png)

### 循环缓冲区



![image-20250312193948057](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312193948057.png)





![image-20250312194041525](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312194041525.png)



### 缓冲池

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779670378.png)

![1741779670378](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779670378.png)

![1741779679210](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779679210.png)

![1741779683095](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779683095.png)

![1741779687563](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779687563.png)

![1741779691211](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779691211.png)

## 磁盘的结构

![1741779731295](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779731295.png)

![1741779736526](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779736526.png)





![1741779740696](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779740696.png)



### 磁盘的物理地址

![1741779822393](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779822393.png)

### 磁盘的分类

![1741779836116](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779836116.png)

![1741779840014](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779840014.png)

![1741779843410](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741779843410.png)

## 磁盘调度算法

Hz：频率单位   

60Hz  ---- 每秒 60 次**周期性变化**

revolve ：旋转

**角速度单位（转速）**

- **1 转/秒（rps, revolutions per ==second==）** = 1 Hz（赫兹）
- **1 转/分钟（rpm, revolutions per ==minute==）** =  1/60 Hz

**Hz和秒有关系** 

- 在机械、汽车、发动机、电机等领域常见，例如：
  - "电机的转速是 3000 rpm" 意味着电机每分钟旋转 3000 次。

---

![image-20250312195814888](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312195814888.png)

### 一次磁盘读/写操作需要的时间

![image-20250312195820482](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312195820482.png)

### FCFS





![1741780530281](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741780530281.png)

### SSTF





![1741780533703](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741780533703.png)

### SCAN





![1741780537349](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741780537349.png)

### LOOK



![1741780540726](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741780540726.png)

### C-SCAN



![1741780544882](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741780544882.png)

### C-LOOK



![1741780548814](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741780548814.png)

![image-20250312195903552](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312195903552.png)

## 减少磁盘延迟时间的方法



![1741780828182](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741780828182.png)

![1741780832073](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741780832073.png)

![1741780835741](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741780835741.png)

![1741780840135](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741780840135.png)

![1741780844008](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741780844008.png)

![1741780848432](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741780848432.png)



![image-20250312200205944](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312200205944.png)



![image-20250312200351716](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312200351716.png)











## 磁盘的管理

![image-20250312200359415](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312200359415.png)

### 磁盘的初始化





![image-20250312200441008](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312200441008.png)

### 引导块

![1741781116531](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741781116531.png)

![1741781121177](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741781121177.png)





### 坏块的处理

![image-20250312200549277](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312200549277.png)

**“坏块对操作系统透明**”是指操作系统在使用存储设备(如硬盘或固态硬盘)时，不会直接感知到坏块的存在。这种“透明性“主要是通过存储设备的控制器和文件系统的管理来实现的。
具体来说，存储设备的控制器(例如硬盘控制器)通常内置了坏块管理机制。当设备检测到坏块时，它会将数据自动重定向到备用的良好存储区域，这称为“坏块映射“或“重映射”。因此，操作系统和应用程序仍然可以正常地读取和写入数据，而不需要意识到这些坏块的存在。



![image-20250312200617130](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312200617130.png)

## 固态硬盘SSD

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/1741781190478.png)

![image-20250312200703835](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312200703835.png)



![image-20250312200731061](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312200731061.png)

NAND 闪存的**最小写入单位是“页”（Page）**，而**最小擦除单位是“块”（Block）**。

**固态硬盘的逻辑块不是块而是页**

！！！

SSD的写入单位是页，而擦除单位是块，块由多个页组成。当需要修改某个页的数据时，由于不能覆盖，SSD控制器会将该页的新数据写入到一个新的空闲页中





![image-20250312200845016](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250312200845016.png)
