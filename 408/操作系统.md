<center>
     <font size="50">操作系统</font>
</center>

---

# 第一章

## 1.操作系统的概念、功能

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915005200289.png)

---

![image-20240915093036428](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915093036428.png)





![image-20240915093542670](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915093542670.png)





![image-20240915094323224](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094323224.png)

==**联机**==就是终端写命令一步一步操作 

==**脱机**==就是执行脚本批处理文件持续执行命令







![image-20240915094938372](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094938372.png)

---





## 2.操作系统的特征

==主要任务：弄清并发和并行 同步和异步以及操作系统的异步性的区别== 

![image-20240915094333194](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094333194.png)



![image-20240915094344084](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094344084.png)

![image-20240915094351429](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094351429.png)



![image-20240915094406060](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094406060.png)







![image-20240915094413541](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094413541.png)



![image-20240915094433740](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094433740.png)





![image-20240915094443450](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915094443450.png)

## 3.操作系统的发展和分类

![image-20240915095055175](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915095055175.png)

### 手工操作阶段

![image-20240918164856888](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918164856888.png)



### 批处理阶段-单道批处理

![image-20240918164935048](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918164935048.png)

![image-20240918165025965](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165025965.png)

### 多道批处理

![image-20240918165128791](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165128791.png)

### 分时操作系统

![image-20240918165136060](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165136060.png)

### 实时操作系统

![image-20240918165144623](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165144623.png)

### 其他操作系统

![image-20240918165153761](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165153761.png)



## 4.操作系统的运行机制

![image-20240918165733241](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165733241.png)

linux指令为==交互式命令接口==

### 内核（kernel）程序 与 应用程序



![image-20240918165745144](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918165745144.png)

### 特权指令和非特权指令

![image-20240918173439655](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173439655.png)

### 内核态和用户态

![image-20240918173451311](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173451311.png)

![image-20240918173458471](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173458471.png)

### 中断--内中断和外中断

![image-20240918173551424](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173551424.png)

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173600041.png)

### 陷入指令

<img src="https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173657012.png" alt="image-20240918173657012" style="zoom:50%;" />



![image-20240918173947661](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173947661.png)

![image-20240918173957209](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173957209.png)

### 中断分类总结

![image-20240918174009573](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918174009573.png)



![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918173856154.png)

查询中断处理程序位置-->中断向量表

![image-20240918174305391](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918174305391.png)



## 5.虚拟机

![image-20240918174536756](C:/Users/33813/AppData/Roaming/Typora/typora-user-images/image-20240918174536756.png)



![image-20240918191809543](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918191809543.png)

指令如果只分特权和非特权的话，那么任何一条特权指令的的使用都要用虚拟机管理程序去截获，

所以对这个特权进行更精确的划分，就可以保证上层操作系统调用时就不用虚拟机管理程序管

### ==重点！！ 两种虚拟机区别==

![image-20240918193812028](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918193812028.png)

### 系统调用与库函数的区别

![image-20240918192333030](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192333030.png)



![image-20240918192357234](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192357234.png)

![image-20240918192417777](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192417777.png)

<b>==因为系统内核操作的就是涉及资源的分配==</b>

![image-20240918192436373](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192436373.png)

### 系统调用的过程



![image-20240918192559512](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192559512.png)

![image-20240918192605290](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192605290.png)

![image-20240918192627694](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240918192627694.png)



# 第二章

## 1.进程与线程

**程序**:是静态的，就是个存放在**磁盘**里的可执行文件，就是一系列的指令集合。
**进程(Process)**:是**动态**的，是程序的一次执行过程
==同一个程序多次执行会对应多个进程==





### 进程的组成---PCB(进程控制块)

![image-20240915101145095](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915101145095.png)

![image-20240915101329910](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915101329910.png)

#### ==程序的运行机制==

![image-20240915101336745](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915101336745.png)



![image-20240915101342672](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915101342672.png)

#### ==进程的特征==

![image-20240915101359469](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20240915101359469.png)



## 2. 进程的状态和转换

![image-20250213122636833](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213122636833.png)

![image-20250213122819582](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213122819582.png)

**在进程运行的过程中，可能会请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应)**

**在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU,并让它进入“阻塞态”**

**当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行**

![image-20250213123054448](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213123054448.png)

![image-20250213123222658](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213123222658.png)

单CPU情况下，**同一时刻只会有一个进程处于运行态**，**多核CPU情况**下，可能有多个进程处于运行态

---

进程PCB中，会有一个**变量state**来表示进程的当前状态。如：1表示创建态、2表示就绪态、3表示运行态.为了对同一个状态下的各个进程进行统一的管理，**操作系统会将各个进程的PCB组织起来。**

![image-20250213123500180](C:/Users/33813/AppData/Roaming/Typora/typora-user-images/image-20250213123500180.png)

大部分都使用的是链接方式



![img](https://raw.githubusercontent.com/kasahuki/os_test/main/img/image-20250213123528155.png)

## 3.进程控制

简化理解：反正进程控制就是要实现进程状态转换

**原语：**原子性的语句

![image-20250213124029315](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213124029315.png)

![image-20250213130021911](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213130021911.png)

![image-20250213130221279](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213130221279.png)

 **进程之间独立**，不共享数据，互不干扰

**子进程**是**由主进程创建的独立进程**

**线程可以访问进程的所有共享资源**，但需要注意**同步问题**（多个线程修改同一变量时可能导致竞争条件）。

**子线程**（Subthread）是一个由主线程创建的线程，它与主线程共享同一个进程的内存空间

![image-20250213131122002](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213131122002.png)

![image-20250213131404572](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213131404572.png)

![	](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213131840308.png)

CPU中会设置很寄存器”，用来存放程序运行过程中所需的某些数据

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213132311610.png)



**无论哪个进程控制原语，要做的无非三类事情：**

 **1.更新PCB中的信息修改进程状态(state)**

 **2.将PCB插入合适的队列保存/恢复运行环境** 

**3.分配/回收资源**



## 4.进程通信

进程间通信(Inter-Process Communication,IPC)是指两个进程之间产生数据交互。

为了保证安全，一个进程不能直接访问另一个进程的地址空间。

![image-20250213185013856](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213185013856.png)

### 共享存储

![image-20250213185529887](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213185529887.png)

各个进程对于这个共享存储区的access是**互斥**的 



### 消息传递

直接通信 / 间接通信





![image-20250213190212731](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213190212731.png)

![image-20250213190331589](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213190331589.png)

---





![image-20250213191112067](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213191112067.png)



**管道是流式数据**，只能按照**顺序**读取，不支持随机访问。 （和共享内存通信的区别）

![image-20250213192935220](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213192935220.png)

![image-20250213193042321](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213193042321.png)



## 5.线程

![image-20250213194536141](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213194536141.png)

**这些系统资源不是分配给进程的**

![image-20250213194812056](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213194812056.png)



![image-20250213195028533](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213195028533.png)

## 线程的实现方式和多线程模型

![image-20250213195128796](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213195128796.png)



![image-20250213200546894](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213200546894.png)



![image-20250213200804371](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213200804371.png)

即便是多核处理器但是由于用户级线程的cpu调度单位是进程而不是线程所以这个进程也只能被分配一个cpu

当某个用户线程执行**阻塞型系统调用**（如文件 I/O、网络 I/O、`sleep()`、`read()` 等），**操作系统会将整个进程设置为“等待”状态**。

**由于用户线程共享同一个进程的执行上下文**，如果该进程被阻塞，那么所有用户线程都无法运行。

 **用户级线程的特点**

| 特性             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| **线程管理**     | **由用户态线程库负责**，操作系统**不感知**用户线程的存在     |
| **切换速度**     | **非常快**，因为线程切换**不涉及内核态**，只需在用户态进行   |
| **系统调用影响** | 进程内**某个用户线程被阻塞，整个进程可能都会阻塞**           |
| **内核调度**     | **内核仍然按照进程调度**，不会单独调度用户线程               |
| **跨平台**       | **可以在不支持内核线程的系统上运行**                         |
| **实现库**       | **POSIX Pthreads（用户级实现）、Java 线程、Go 协程、Python 线程（GIL 影响）** |

---

![image-20250213201550666](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213201550666.png)





### 一对一模型

![image-20250213201742198](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213201742198.png)



### 多对一模型

![image-20250213215510426](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213215510426.png)

**多对一模型**，也就是多个用户级线程映射到一个内核级线程。用户级线程是由用户空间的库来管理的，比如早期的POSIX线程库，而内核对此并不知情，内核只能看到那个单独的内核线程。所以当其中一个用户线程执行阻塞操作时，比如I/O操作，由于内核只知道那个内核线程，所以整个内核线程会被阻塞。而因为所有用户线程都依赖于这个唯一的内核线程来执行，所以整个进程的其他用户线程也无法继续运行，导致整个进程阻塞



- 内核级线程是操作系统调度和分配CPU资源的基本单位。
- 用户级线程的所有操作（包括计算、I/O等）最终都需要通过内核级线程来执行。
- 内核级线程为用户级线程提供了**CPU时间片**，使得用户级线程能够在CPU上运行

### 多对多模型

![image-20250213215906295](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213215906295.png)



## 线程的状态和转换



![image-20250213215900766](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213215900766.png)

## 线程的组织和控制

**TCB 这样的数据结构就表示着一个线程 与PCB类似**





![image-20250213220246906](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213220246906.png)



## 6.调度

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。

在操作系统中，调度是管理进程执行的重要机制，主要分为**高级调度**、**中级调度**和**低级调度**。这三种调度各自负责不同层次的任务，具体如下：

**==高级调度==**

**定义**：高级调度（也称作业调度或长程调度）负责从外存（如硬盘）中选择作业，将其加载到内存中并为其分配必要的资源。

**功能与过程**：
- 选择后备队列中的作业，将其调入内存。
- 创建进程控制块（PCB），以便管理进程的状态和资源。
- 决定何时将作业从外存移入内存，通常依据系统的负载和资源可用性。
- 调度频率较低，通常每几分钟进行一次。

**==中级调度==**

**定义**：中级调度（也称内存调度或平衡调度）主要负责在内存和外存之间交换进程，以提高内存利用率和系统吞吐量。

**功能与过程**：
- 将暂时不能运行的进程挂起，并将其移至外存。
- 根据内存的使用情况和进程的状态，决定哪些挂起的进程可以重新调入内存。
- PCB常驻内存，以便于管理和监控进程状态。
- 调度频率中等，可能会在进程状态变化时频繁发生。

**==低级调度==**

**定义**：低级调度（也称进程调度或短程调度）负责在就绪队列中选择一个进程并将CPU分配给它。

**功能与过程**：
- 从就绪队列中选择一个进程，将处理器分配给该进程执行。
- 进行上下文切换，保存当前进程的状态并加载新进程的状态。
- 调度频率高，通常每几秒钟就会发生一次，以确保系统响应及时。



### 高级调度（作业调度）

![image-20250213221344910](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213221344910.png)

**内存**是计算机的临时存储空间，用于存放正在运行的程序和数据。（也就是**进程**的空间）

CPU直接从内存中读取指令和数据 进程的执行依赖于CPU从内存中读取指令并执行

**操作系统**负责管理内存分配、进程调度和CPU资源分配







### 低级调度（进程调度）

![image-20250213223103383](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213223103383.png)







### 中级调度（内存调度）



![image-20250213222558840](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213222558840.png)

---



**在操作系统中，调度分为高级调度、中级调度和低级调度。以下是每种调度的实际例子：**

**高级调度**

**例子**：在一个批处理系统中，用户提交了多个作业（如数据处理、报告生成等）。这些作业首先存储在外存的后备作业队列中。高级调度的任务是从这个队列中选择一些作业，将它们加载到内存中并创建相应的进程。

- **具体过程**：
  - 用户提交作业A、B、C。
  - 操作系统根据设定的策略（如优先级、资源需求等）选择将作业A和B加载到内存中。
  - 为这两个作业创建进程控制块（PCB），并将它们放入就绪队列，准备竞争CPU资源。

中级调度

**例子**：在一个多任务操作系统中，内存资源有限，某些进程可能暂时不能运行。中级调度负责将这些暂时不需要的进程挂起，移至外存，以释放内存给其他需要执行的进程。

- **具体过程**：
  - 进程X正在运行，但由于内存不足，操作系统决定将进程Y挂起并移至外存。
  - 当内存有空闲时，操作系统再将进程Y调入内存，并修改其状态为就绪状态，以便可以再次执行。

低级调度

**例子**：在一个实时操作系统中，多个进程处于就绪状态等待CPU执行。低级调度负责从就绪队列中选择一个进程并将其分配给CPU。

- **具体过程**：
  - 就绪队列中有进程P1、P2和P3。
  - 操作系统使用轮转调度算法，首先选择进程P1分配CPU。
  - 当P1的时间片用完后，操作系统将其挂起，并选择下一个就绪的进程P2继续执行。

通过这三个层次的调度，操作系统能够高效地管理资源，提高系统性能和响应能力。

---

## 7.进程调度的时机、切换、过程与方式

<span style="font-size:1.6em;">**I/O中断的工作原理**</span>

1. **中断请求**：当外部设备完成I/O操作（例如，数据从硬盘读取完成），它会向CPU发送一个中断请求信号。这通常是通过I/O控制器实现的。
2. **CPU响应**：一旦CPU接收到中断信号，它会暂时停止当前正在执行的程序，并保存其状态，以便稍后恢复。
3. **执行中断处理程序**：CPU转向预先定义的中断处理程序，执行相应的代码以处理该I/O操作的结果。例如，它可能会将读取的数据从内存中的缓冲区移动到用户程序指定的位置。
4. **恢复执行**：处理完中断后，CPU会恢复之前被中断的程序，从它停止的地方继续执行

![image-20250213230825635](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213230825635.png)



![image-20250213231331878](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213231331878.png)



![image-20250213231345037](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213231345037.png)

![image-20250213231416527](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213231416527.png)

<span style="font-size:1.9em; font-weight:bold; color:#FF0000;">进程调度的方式</span>

![image-20250213231948719](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213231948719.png)

![image-20250213232531868](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213232531868.png)

![image-20250213232541096](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250213232541096.png)

## 8.调度器（调度程序 scheduler）和闲逛（idle）进程

![image-20250215211111802](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215211111802.png)



![image-20250215211205604](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215211205604.png)

CPU（中央处理器）几乎是无时无刻都在运行的。这是因为操作系统和应用程序需要不断地执行指令来完成各种任务，从处理你的输入输出请求到运行应用程序和维护系统的基本功能。即使你的计算机看似闲置，CPU 也会持续地执行一些基本的任务，例如维护系统时钟和处理后台进程。这种持续运行的状态保证了计算机能够随时响应你的操作和需求。

*计组部分知识

**零地址指令**（Zero Address Instruction）是一种计算机指令格式，它不需要显式地指定操作数或操作数的地址（也就是不需要访存）。相比之下，其他指令格式可能需要指定一个或多个操作数的地址或寄存器。零地址指令通常设计用于栈式计算机或者某些指令集体系结构中，其中操作数可以隐含地从栈顶或者特定的寄存器中获取。

在零地址指令中，指令本身包含了足够的信息来执行操作，而不需要额外的操作数地址信息。这种设计简化了指令的格式和编码，同时也能够加快执行速度



![image-20250215211812266](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215211812266.png)

## 9.调度算法的评价指标

![image-20250215211842647](C:/Users/33813/AppData/Roaming/Typora/typora-user-images/image-20250215211842647.png)

![image-20250215212113827](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215212113827.png)

<span style="font-size:1.5em; color:#FF0000;">**通过课后习题&习题课学习做法**</span>



---

 ![image-20250215212339994](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215212339994.png)

  

周转时间是相对于作业来说的，所以平均周转时间就是平均每个作业的周转时间

**周转时间**  就是提交**（到达）**到完成这个时间  （也就是整个生命周期时间）

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215212850032.png)

![image-20250215213121741](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215213121741.png)

**等待时间**

 ![image-20250215214137062](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215214137062.png)

**响应时间**

![image-20250215214504440](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215214504440.png)





## 10.调度算法

 ![ ](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215214540708.png)

**==作业==提交阶段**：

- 用户提交一个作业（如一个程序任务）给操作系统。
- 作业被放置在**==外存后备队列==**中等待。

**调度阶段**：

- 操作系统从外存后备队列中选择一个作业。
- 选择的标准可能包括作业的优先级、资源需求等。

**进程创建阶段**：

- 选中的作业被加载到内存中，操作系统为其创建一个或多个进程。
- 每个进程被分配到相应的内存空间，并分配执行所需的资源。

**执行阶段**：

- ==进程==被放置在==就绪队列==中，等待处理器的分配。 
- 一旦处理器可用，操作系统会从就绪队列中选择一个进程，将其调度到处理器上执行。

**执行结束及资源释放**：

- 进程执行完毕或者被中断后，操作系统可能将其从处理器移除，并释放相关资源。

- 结束的进程的状态可能会被更新并记录，然后可能将结果返回给用户或者存储到外存

  

  ---

  

  IO中断会唤醒阻塞进程是因为阻塞进程在执行IO操作时需要等待外部设备（如硬盘、网络接口等）完成特定的IO操作，这期间进程无法继续执行其他任务，处于阻塞状态。当外部设备完成IO操作并触发了IO中断时，操作系统会进行以下处理：

  1. **中断处理程序**：
     - 当IO操作完成时，外部设备会发送一个中断信号给CPU。
     - 操作系统会调用与该IO操作相关的中断处理程序（IRQ处理程序），该程序会处理中断并根据中断的类型进行相应的处理。
  2. **唤醒阻塞进程**：
     - 如果阻塞进程是因为等待某个IO操作而阻塞的，中断处理程序会根据进程的状态将其从阻塞状态转换为就绪状态（Ready）。
     - 这意味着操作系统认为进程现在可以继续执行，因为所需的IO操作已经完成。
  3. **状态转换**：
     - 一旦进程被唤醒并放入就绪队列，操作系统的调度程序会在适当的时候将其调度到CPU上执行。
     - 进程在恢复执行后可以继续处理IO操作的结果或者执行接下来的任务。

## 先来先服务：

 ![image-20250215223930398](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215223930398.png)



![image-20250215224051211](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215224051211.png)

注意非抢占式调度算法：

非抢占式调度算法通常通过进程主动放弃CPU或者在IO等待时让出CPU，而不会被操作系统强制剥夺CPU资源。

这种调度方式可以带来一定程度的**同步效果**，因为**进程的执行是有序的，一个进程执行完毕或者等待IO时，另一个进程才能开始执行。**

## 短作业优先：

![image-20250215225441511](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215225441511.png)

---



![image-20250215232540150](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215232540150.png)

  

![image-20250215233228600](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215233228600.png)

![image-20250215233347077](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215233347077.png)

## 高响应比优先算法：

![image-20250215233911055](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215233911055.png)

![image-20250215234020808](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215234020808.png)

![image-20250215234017984](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215234017984.png)

![image-20250215234043955](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250215234043955.png)

## 时间片轮转调度算法（RR）![image-20250225190744420](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225190744420.png)

![image-20250225190812960](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225190812960.png)

![image-20250225190954170](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225190954170.png)

![image-20250225190829203](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225190829203.png)

![image-20250225190843416](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225190843416.png)

![image-20250225191009295](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191009295.png)

## 优先级调度算法

### 非抢占式

![](C:/Users/33813/AppData/Roaming/Typora/typora-user-images/image-20250225191028644.png)

### 抢占式

![image-20250225191050991](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191050991.png)

![image-20250225191123342](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191123342.png)



![image-20250225191145238](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191145238.png)

## 多级反馈调度算法





![image-20250225191213150](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191213150.png)



![image-20250225191220309](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191220309.png)



![image-20250225191227299](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191227299.png)

![image-20250225191316466](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191316466.png)



## 多级队列调度算法

![image-20250225191435938](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225191435938.png)



**多级队列调度**
将进程分成多个固定队列，每个队列对应一个优先级。
队列中的进程优先级是静态的，不会在不同队列间移动。
调度器按照优先级顺序调度队列中的进程，高优先级队列中的进程先被调度。



**多级反馈队列调度**
允许进程在不同队列之间移动，优先级是动态调整的。
一个进程执行完一个时间片后，如果没有完成任务，会被移动到低优先级的队列中。
通过降低长时间运行进程的优先级，实现更加公平的资源分配和防止某些进程长期占用CPU资源。

## 11.同步与互斥

### 基本概念

![image-20250225192047716](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225192047716.png)

![image-20250225204331799](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225204331799.png)

**实现互斥访问的==四个原则==**

![image-20250225204338361](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225204338361.png)





### 进程互斥的软件实现方法

#### 单标志法

**最大问题：违反“空闲让进的问题”**

**要是a一直不使用他也不会让所以b就一直进不去**

![image-20250225205242025](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250225205242025.png)

#### 双标志先检查

![image-20250226215720162](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250226215720162.png)

![image-20250226215736656](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250226215736656.png)

#### 双标志后检查

![image-20250226215742324](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250226215742324.png)

#### Peterson 算法

![image-20250226215748089](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250226215748089.png)



![image-20250226215812192](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250226215812192.png)



![image-20250226215846116](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20250226215846116.png)

### 进程互斥的硬件实现方法



### 互斥锁



### 信号量机制



### 用信号量实现进程互斥、同步、前驱关系



### 生产者-消费者问题



### 多生产者-多消费者问题





### 吸烟者问题



### 读者-写者问题



### 哲学家进餐问题



### 管程



### 死锁



### 死锁的处理策略

#### 预防死锁



#### 避免死锁



#### 检测和解除





# 内存

## 1.内存的基础知识
