# long long 但凡涉及到 加 乘 一定要注意数据范围（重要）能用就都用long long

**typedef long long ll**

**10^8 (一个亿以内)就不会超时 （1s）**

# Think over the box here :

### 审题 不是三个数相乘而是拼接

![image-20241004222557306](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241004222557306.png)

**1.0 别乱乘 ： a/1.0*b （a/b）  这样就改变原来的算式了！！！！！！**  

# 模板注意事项

## signed问题



**使用signed 注意格式化输入（scanf）时 要用 %lld**

## 闰年判断

**if(*year*%400 == 0||*year*%100 != 0 && *year*%4 == 0) *// 闰年判断***





# ==一、dfs==

## ==飞机降落==

### 暴力法1 73分 剪枝的不够彻底！

~~~c++
#include<iostream>
#include<algorithm>
using namespace std;
const int N=20;
int n;
bool st[N];
bool flag=0;  //只用一次跳出的技巧！！！！！！！！！！！！！！！！！！！！
int p[N];
struct plane
{
    long long  t;//最早可以于t时刻降落
    long long d;//最多可以盘旋多少时间
    long long l;//降落需要多少时间
};
void dfs(plane pla[],int u)//n-1个元素
{
    if(flag)//剪枝如果已经找到了就不用再找了！！！！
    return ;
  if(u==n)
  {
      int curtime=pla[p[0]].t;
      for(int i=0;i<n;i++)
      {
          if(curtime>pla[p[i]].t+pla[p[i]].d)
          return ;
          curtime+=pla[p[i]].l;
          
      }
      flag=1;
      return ;
  }
  for(int i=0;i<n;i++)
  {
      if(!st[i])
      {
          st[i]=1;
          p[u]=i;
          dfs(pla,u+1);
          st[i]=0;
      }
  }
}
int main()
{
    int t;
    cin>>t;
     
    while(t--)
    {
       flag=0;
        cin>>n;
        plane pla[N];
        for(int i=0;i<n;i++)cin>>pla[i].t>>pla[i].d>>pla[i].l;
        sort(pla,pla+n,cmp);
        dfs(pla,0);
        if(flag==1)cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
     
    }
     
    return 0;
}
~~~

### 暴力法2 

~~~C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N=20;
int n;
bool st[N];
bool flag=0;
int p[N];
struct plane
{
    long long  t;//最早可以于t时刻降落
    long long d;//最多可以盘旋多少时间
    long long l;//降落需要多少时间
};
bool cmp(plane a,plane b)
{
    if(a.t!=b.t)
    return a.t<b.t;
}
void dfs(plane pla[],int u,int curtime)//n-1个元素
{
    if(flag)//剪枝如果已经找到了就不用再找了！！！！
    return ;
    if(u==n)
    {
        flag=1;
        return ;
    }
    
    for(int i=0;i<n;i++)
    {
        
        if(!st[i])
        {
            if(u==0)
            {
                
                st[i]=1;
                dfs(pla,u+1,pla[i].t+pla[i].l);
                st[i]=0;
              
            }
            else
            {
                 curtime=max(curtime,pla[i].t);//正确剪枝
                 if(curtime<=pla[i].t+pla[i].d)
                 {
                     st[i]=1;
                   
                     dfs(pla,u+1,curtime+pla[i].l);
                     st[i]=0;
                     
                 }
                 else
                 return ;
                 
            }
           
            
            
        }
    }
  
}
int main()
{
    int t;
    cin>>t;
     
    while(t--)
    {
       flag=0;
        cin>>n;
        plane pla[N];
        for(int i=0;i<n;i++)cin>>pla[i].t>>pla[i].d>>pla[i].l;
        sort(pla,pla+n,cmp);
        dfs(pla,0,0);
        if(flag==1)cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
     
    }
     
    return 0;
}
~~~

#### 此题思维：



> 特判：==如果当前时间比接下来的飞机最早降落时间早，（如果不max）就默认了下一个飞机是在当前时间降落实际上不是！！！==



## **注意点：**

**越界（数组）**

**数据类型（long long）范围**

**初始化（多组数据时 / 循环回归时 重新初始化变量 ）**

特判，指涉为空 （空指针，容器为空时弹出），

****

## ==字符串处理==

### ==子串简写==

~~~C++
#include<iostream>
using namespace std;
int main()
{
    long long ans=0;
    int k;
    cin>>k;
    string s;
    cin>>s;
    char a,b;
    cin>>a>>b;
    //输入
    int flag=0;
    if(s.size()<k||s.size()<=2)//特判
    {
        cout<<0;
        return 0;
    }
    for(int i=0,j=k-1;i<s.size();i++,j++)
    {
        if(s[i]==a)flag++;//记录a的个数
        
        if(s[j]==b)ans+=flag;//只要有b就和之前的a记录答案
        
    }
    
    
    cout<<ans;
   
    return 0;
}
~~~

#### 此题思维

![image-20241002111051754](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241002111051754.png)

#### 二分法

~~~C++
#include<iostream>
#include<vector>
using namespace std;
vector<int> ans;
long long sum;
int main()
{
    int k;
    cin>>k;
    string s;
    char a,b;
    cin>>s>>a>>b;
    for(int i=0;i<s.size();i++)
    {
        if(s[i]==a)
        
          ans.push_back(i);//将a的下标存进去 //存下标技巧   
    
        //if和else if 注意 区别！！！
        
         if(s[i]==b&&!ans.empty())//不能else if 万一相等（a等于b）怎么办
        {
             //特判！！！！！
            
            int t=i;//记住当前下标
            int l=0,r=ans.size()-1;
            while(l<r)
            {
                int mid=l+r+1>>1;
                if(t-ans[mid]+1>=k)//二分部分重点研究
                l=mid;
                else
                r=mid-1;
            }
            if(t-ans[l]+1>=k)//找到的答案一定要满足条件
            sum+=l+1;
            
        }
        
    }
    cout<<sum;
    
    
    return 0;
}
~~~



**技巧1：存下标**

**技巧2：一边遍历一 边存 ，不用全部存住再判断这样可以简略一些判断步骤**

[hash技巧（重复问题）](#hash)




## ==单词接龙==

~~~C++
#include<iostream>
#include<vector>
#include<map>
using namespace std;
int n;
vector<string>s;
map<string,int>st;//map映射
string ans;
void dfs(int u)
{
   
}
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        string c;
        cin>>c;
        s.push_back(c);
    }
    char head;
    cin>>head;
   
    //输入
    dfs(0);
   
    
    
    
    return 0;
}
~~~



## ==暴力+链表+优先队列==


## ==吃奶酪==

###  暴力搜索 +剪枝+记忆化搜索 （！！！！）



~~~c++
#include<iostream>
#include<cmath>
using namespace std;
const int N=20;
double cur_pos;
double Min=999999999.0;
bool st[N];
int p[N];
int n;

struct pos
{
    double x;
    double y;
    
}a[N];
void dfs(int u,double x,double y)//当前坐标
{
    if(u==n)
    {
        Min=min(Min,cur_pos);
        return ;
    }
    if(cur_pos>=Min)
    return ;  //剪枝1
    for(int i=0;i<n;i++)
    {
        if(!st[i])
        {
            st[i]=1;
            
            cur_pos+=sqrt((a[i].x-x)*(a[i].x-x)+(a[i].y-y)*(a[i].y-y));
            dfs(u+1,a[i].x,a[i].y);
            st[i]=0;
            cur_pos-=sqrt((a[i].x-x)*(a[i].x-x)+(a[i].y-y)*(a[i].y-y));
        }
    }
}
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)cin>>a[i].x>>a[i].y;
    dfs(0,0,0);
    printf("%.2f",Min);
    return 0;
}
~~~

## ==自然数拆分问题==

![image-20241002205652744](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241002205652744.png)

~~~C++
#include<iostream>
using namespace std;
const int N=20;
int p[N];
int n;
void dfs(int u,int sum)//当前数位数 和总和
{
    if(sum==n&&u>1)
    {
        for(int i=0;i<u-1;i++)
        cout<<p[i]<<'+';
        cout<<p[u-1]<<endl;
    }
    
    
    if(sum>n)return;
    
    for(int i=1;i<=n-sum;i++)//横向遍历
    {
        if(u==0||i>=p[u-1])
    {
         p[u]=i;
        sum+=i;
        dfs(u+1,sum);
        sum-=i;
    }
       
        
        
    }
}

int main()
{
   
    cin>>n;
    dfs(0,0);
    return 0;
}
~~~

## ==单词方阵==

**（八方向去一个方阵中找一个连续八方向排列的 “ yizhong”）**



~~~C++
#include<iostream>
using namespace std;
const int N=110;
int dx[]={-1,-1,0,1,1,1,0,-1};
int dy[]={0,1,1,1,0,-1,-1,-1};
char a[N][N];
bool st[N][N];
bool flag[N][N]={0};
int p[N];
int n;
const string pat="#yizhong";//存！！！------------------------------------------------------
void dfs(int x,int y,int u,int sign)
{
    if(x<=0||x>n||y>n||y<=0)
        return ;
    if(st[x][y])return ;
    if(a[x][y]!=pat[u])
    return ;
   //不满足就返回（提前剪枝）
    if(u==7)//说明找到了
    {
        for(int i=0;i<7;i++)
        {
            flag[x][y]=1;
            int nx=x-dx[sign];
            int ny=y-dy[sign];//倒退
            x=nx;
            y=ny;
        }
        return ;
    }
    st[x][y]=1;
    for(int i=0;i<8;i++)
    {
        if(u==1||i==p[u-1])//保证一直都是一个方向
        {
            p[u]=i; //巧妙存储当前层使用的矢量下标
            dfs(x+dx[i],y+dy[i],u+1,i);   //只有满足条件才dfs 
        }
        // 这里是返回区
   -->  else
        break;  <-- 
        // 为什么一注释就正确了
     

    }
    st[x][y]=0;
}
int main()
{

    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            cin>>a[i][j];
            //输入
            
     //一旦遇到y就开始dfs       
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(a[i][j]=='y')
            {
                dfs(i,j,1,0);
            }
        }
    }
    //标记操作
      for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(flag[i][j]==0)
                a[i][j]='*';
        }
        
    }
    //输出
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cout<<a[i][j];
        }
        cout<<endl;
    }
    
            
    return 0;
}
~~~

#### **==具体逻辑思维：==**

**为什么会进入 `else`分支？**:

``

**因为 dfs后<font color=red size=6>重新</font>进入到for循环后u不等于1并且与上次（i==2）的方向矢量下标不一样时就会退出不会尝试其他方向了**、





# ==Flood Fill 与搜索虚拟轴==

### 水坑问题



![image-20241003081822542](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241003081822542.png)





~~~C++
#include<iostream>
using namespace std;
int n,m;
const int N=110;
char mp[N][N];
int ans;

//虚拟轴
void dfs(int x,int y)
{
    if(x>n||x<=0||y>m||y<=0)
    return ;
    if(mp[x][y]=='.')return ;
    mp[x][y]='.';//感染操作
     //只要是水坑就dfs周围八个网格
    //也可以八方向
    for(int i=-1;i<=1;i++)
    {
        for(int j=-1;j<=1;j++)
        {
            int nx=x+i;
            int ny=y+j;
            dfs(nx,ny);
        }
    }
}
int main()
{
  
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
         cin>>mp[i][j];
    for(int i=1;i<=n;i++)
    {
      for(int j=1;j<=m;j++)
      {
          if(mp[i][j]=='W')
          {
              dfs(i,j);
              ans++;
          }
      }
    }
        
        cout<<ans;
    
    return 0;
}
~~~

### ==填色问题==

![image-20241003085552781](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241003085552781.png)

#### 超时

~~~C++
#include<iostream>
using namespace std;
const int N=40;
int mp[N][N];
int n;
int flag=0;
int dx[]={-1,0,1,0};
int dy[]={0,1,0,-1};
bool st[N][N];
bool sign[N][N];
void dfs(int x,int y)
{
    if(flag==1)return ;
   
     if(x>n||y>n||x<=0||y<=0||sign[x][y])//如果走到边界了
    {
        flag=1;
        return ;
    }
    if(mp[x][y]==1||mp[x][y]==2)return ;
   
   
    
    //判断非法状态
    if(st[x][y])return ;
    st[x][y]=1;
    
    for(int i=0;i<4;i++)
    {
        
        dfs(x+dx[i],y+dy[i]);
        
    }
    st[x][y]=0;
    
 
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        cin>>mp[i][j];
    for(int i=1;i<=n;i++)
    {
      for(int j=1;j<=n;j++)
      {
          if(mp[i][j]==0)
          {
              flag=0;
              dfs(i,j);
              if(flag!=1)
              {
                 mp[i][j]=2;
              }
              else
              sign[i][j]=1;
            
          }
          
      }
    }
       
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            cout<<mp[i][j]<<" ";
        }
        cout<<endl;
        
    }
    
    
    
    return 0;
}
~~~



#### 优化技巧

~~~C++
#include<iostream>
#include<vector>
using namespace std;

const int N = 40;
int mp[N][N];
int n;
int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};
bool visited[N][N];  // 访问状态记录

// 用于记录当前连通块的所有坐标
vector<pair<int, int>> current_block;
bool touches_boundary;

void dfs(int x, int y) {
    if (x > n || y > n || x <= 0 || y <= 0) {
        touches_boundary = true;  // 如果走到边界，则该连通块不能标记为2
        return;
    }
    if (mp[x][y] == 1 || visited[x][y]) return;  // 遇到障碍物或已访问则返回

    visited[x][y] = true;
    current_block.push_back({x, y});  // 记录当前连通块的坐标

    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        dfs(nx, ny);
    }
}

int main() {
    cin >> n;
    
    // 读入地图
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> mp[i][j];
        }
    }

    // 遍历每个格子
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (mp[i][j] == 0 && !visited[i][j]) {
                current_block.clear();
                touches_boundary = false;

                // 对当前格子进行DFS，找出整个连通块
                dfs(i, j);

                // 如果该连通块不碰到边界，则标记为2
                if (!touches_boundary) {
                    for (auto& p : current_block) {
                        mp[p.first][p.second] = 2;
                    }
                }
            }
        }
    }

    // 输出修改后的地图
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cout << mp[i][j] << " ";
        }
        cout << endl;
    }

    return 0;
}
~~~

### 全球变暖

### BFS判断联通块

![image-20241003095825395](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241003095825395.png)

~~~C++
#include<iostream>
#include<queue>
using namespace std;
typedef pair<int,int> PII;
const int N=1e3+10;
int n;
char mp[N][N];
int tot,bnd;
bool st[N][N];
int ans;
int dx[]={-1,0,1,0};
int dy[]={0,1,0,-1};
int cnt;//记录有多少岛屿
void bfs(int sx,int sy)
{
    queue<PII>q;
    q.push({sx,sy});
    cnt++;
------------------------------------
    st[sx][sy]=1;
-----------------------------------
 
    
    while(!q.empty())
    {
        auto t=q.front();
        tot++;
        q.pop();
        ----------------------
        bool is_bound=0; 
        ---------------------
        for(int i=0;i<4;i++)
        {
            int x=t.first+dx[i];
            int y=t.second+dy[i];
           ---------------------------------------------------
            //判断合法区域
            if(x<0||y<0||x>=n||y>=n)
            continue;
            if(st[x][y])continue;//
           ------------------------------------------------------ 
           -------------------------------------------------- 
            if(mp[x][y]=='.')
            {
                is_bound=1;
                //不能在这bnd++;
                continue;
            }
           -------------------------------------------------------------- 
            q.push({x,y});
            st[x][y]=1;
          
            
        }
        if(is_bound)bnd++;
        --------------------------------------------------------------
        
    }
}
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)scanf("%s",mp[i]);
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(!st[i][j]&&mp[i][j]=='#')
            {
                bnd=0,tot=0;
                bfs(i,j);//传入坐标
                if(bnd==tot)
                ans++;
            }
        }
    }
    // cout<<cnt<<endl;
    cout<<ans;
    return 0;
}

~~~









# 深度剪枝 （学习剪枝套路）

## ==电梯问题==



~~~c++
#include<iostream>
using namespace std;
#define int long long 
const int N=220;
int n,a,b;
int Min=1e18;
bool flag=0;
int sta[N];
struct button
{
    int up;
    int down;

}mov[N];
void dfs(int pos,int ans)//当前楼层
{
   if(pos<=0||pos>n)return ;//pos >=n 不行 因为如果终点就在第n层呢 问题1
   
   if(ans>=Min)//最值剪枝法！！！（必写）
   return ;
 -----------------------------------------------------------------  
   if(ans>=sta[pos])return ;//为什么要加等于号不可  -->优化剪枝//问题三
   //这个位置是否之前抵达过且比现在抵达的次数要（思路）；
 ________________________________________________________________
   
   
   if(pos==b)
   {
      Min=min(Min,ans); 
      flag=1;
      return ;
    
   }
   ________________________________________________________________
   
       
       sta[pos]=min(sta[pos],ans);//问题2
    
   ________________________________________________________________
   dfs(pos+mov[pos].up,ans+1);
   
   dfs(pos+mov[pos].down,ans+1);
}
signed main()
{
    cin>>n>>a>>b;
    for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        mov[i]={x,-x};
        sta[i]=1e18;
    }
    dfs(a,0);
    if(flag)
    cout<<Min;
    else
    cout<<-1;
    return 0;
}
~~~

# 数学优化 & long long、、

![image-20241003111053864](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241003111053864.png)

~~~C++
#include<iostream>
using namespace std;
#define int long long
int a,b,n;


signed main()
{
    cin>>a>>b>>n;
    int res=a*5+b*2;//一周的做题数量
    int sum=n/res*7;  //需要几周
    int rest=n%res;//剩余题目数
    int day=1;
    
    while(rest>0)
    {
        if(day>7)
        day=1;
        if(day<=5)
            rest-=a;
        else
            rest-=b;
        day++;
        sum++;
        
    }
   
    cout<<sum;
    return 0;
}
~~~

## 修建灌木

![image-20241003113549923](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241003113549923.png)

~~~c++
#include<iostream>
using namespace std;
#define int long long
const int N=1e5+10;
int a[N];
int n;
int maxn[N];
void trim(int x)
{
    for(int i=0;i<n;i++)
    {
        if(i==x)
        {
            a[i]=0;
            continue;
        }
        a[i]++;
    }
}
signed main()
{
 
    cin>>n;
    int s=0;
    int sign=1;
    int cnt=3;//数学思维
    while(cnt--)
    {
        if(sign%2!=0)
        {
            for(int i=0;i<n;i++)
            {
              
              maxn[i]=max(maxn[i],a[i]);
              trim(i); 
            }
        }
        else
        {
            for(int i=n-1;i>=0;i--)
            
            {
                maxn[i]=max(maxn[i],a[i]);
                trim(i);
            }
        }
        sign++;
       
        
    }
    for(int i=0;i<n;i++)cout<<maxn[i]<<endl;
    
    return 0;
}
~~~

# ==前缀和+双指针==

## 统计有几个子矩阵和不大于k

### 暴力法

[多重循环就和排列组合很像](#暴力枚举)

~~~C++
#include<iostream>
using namespace std;
#define int long long
const int N=550;
int a[N][N],s[N][N];
int ans;
signed main()
{
    int n,m,k;
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
            //构造二维前缀和
    for(int x1=1;x1<=n;x1++)//四重循环
    {
        for(int y1=1;y1<=m;y1++)
        {
            for(int x2=x1;x2<=n;x2++)//x2不能从1开始 不然会重复无用功
            {
                for(int y2=y1;y2<=m;y2++)
                {
                    if(s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]<=k)
                    ans++;
                }
            }
        }
    }
   
    cout<<ans;
    return 0 ;
}
~~~

### 优化（双指针优化暴力枚举（n重循环））

[类似题目](#拔河)



~~~C++

~~~







# 二、==填空暴力枚举和递归搜索==

## 搜索

### ==基本问题解答：==



### 问题 ： 下标对应问题&&初始化问题 简洁

> 223344AA p[]数组存的是下标序列 e.g. 326451705 对应的就是 32A44A22 所以要使用绝对值（==逆序问题==）
>
> 那如果使用p【i】不使用 i 的话 p[7]-p[6]-1 就不对了 i 是出现的位置

![image-20241003190955393](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241003190955393.png)

### 扑克牌序列

~~~C++
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
//字典序 2 3 4 a
//2342A3A4
vector<char>a;
int p[10];
bool flag=0;
bool st[9];
int p2,pa,p3,p4;
int flag2,flaga,flag3,flag4;
void dfs(int u)
{
  
  if(flag)return ;
  
    if(u==8)//0有状态 所以时0-7 到8就是处理0-7的元素
    {
        ------------------------------------------
         flag2 = flaga = flag3 = flag4 = 0;
        p2 = pa = p3 = p4 = -1;
        -----------------------------------------
            //初始化问题
        for(int i=0;i<8;i++)
        {
            if(a[p[i]]=='2')
            {
                if(flag2==1)
                {
                    if(abs(i-p2)-1!=2)
                    return ;
                }
                //简化为if多重判断！
           
                flag2++;
                p2=i;
             }
            else if(a[p[i]]=='A')
            {
                if(flaga==1)
                {
                    if(abs(i-pa)-1!=1)
                    return ;
                }
                flaga++;
                pa=i;
            }
            else if(a[p[i]]=='3')
            {
                if(flag3==1)
                {
                    if(abs(i-p3)-1!=3)return ;
                }
                flag3++;
                p3=i;
            }
            else if(a[p[i]]=='4')
            {
                if(flag4==1)
                {
                    if(abs(i-p4)-1!=4)return ;
                }
                flag4++;
                p4=i;
            }
        }
        
        for(int i=0;i<8;i++)cout<<a[p[i]];
        flag=1;
        return ;
    }
    
    for(int i=0;i<8;i++)
    {
        if(!st[i])
        {
            st[i]=1;
            p[u]=i;
            dfs(u+1);
            st[i]=0;
        }
    }
}
int main()
{
    string s;
    cin>>s;
    for(int i=0;i<s.size();i++) a.push_back(s[i]); 
    dfs(0);
    
    return 0;
}
~~~





### 李白打酒

![image-20241003124156656](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241003124156656.png)

~~~C++
#include<iostream>
using namespace std;

int ans;
//遇到店5次遇到花9次
void dfs(int x,int y,int n)
{
   
    if(n==1&&x==5&&y==9)   //if(n==1) 单单这样不行 ，万一没用到5个和9个就只剩一斗了
    {
        ans++;
        return ;
    }
    ------------------------------------------------
    if(x<5)
    dfs(x+1,y,n*2);
    
    if(y<9)
    dfs(x,y+1,n-1);
    -------------------------------------------------
        //   if(x>5||y>9)return ;//不能取等 因为 取等返回的话找另一个分支时x就是不会到五  画出递归搜索树就很明白了
        
        //   dfs(x+1,y,n*2);
    	//   dfs(x,y+1,n-1);
        //等效
        
    
    
    //画出递归搜索树检查
    
}
int main()
{
    dfs(0,0,2);    
    cout<<ans;
    return 0;
}
~~~

![image-20241003154715827](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241003154715827.png)

![image-20241003154721754](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241003154721754.png)

画出树，看看0层有无存状态

### 六边形填数

![image-20241003140549725](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241003140549725.png)

~~~C++
#include<iostream>
using namespace std;
int a[9]={2,4,5,6,7,9,10,11,12};//数组存数技巧
int p[10];
bool st[13];
bool flag=0;
void dfs(int u)
{
    if(flag)return ;
    if(u==9)//找到了一个序列 0-8 有9个
    {
        < 技巧：————————————————————————————————————————————————————————————————————————————————————>
        
        ——————————————————————————————————————————————————————————————————————————————————————————
        //p[]存的就是0-8的排列数（有顺序）
        //通过p[] 来索引a数组 存下标真的是个很巧妙的方法 
           
        <——————————————————————————————————————————————————————————————————————————————————————————>
        int x1=1+a[p[0]]+a[p[1]]+a[p[2]];
        int x2=1+a[p[3]]+a[p[4]]+a[p[5]];
        int x3=a[p[2]]+a[p[6]]+a[p[7]]+a[p[5]];
        int x4=8+a[p[0]]+a[p[3]]+a[p[8]];
        int x5=8+a[p[1]]+a[p[6]]+3;
        int x6=3+a[p[8]]+a[p[7]]+a[p[4]];
        if(x1==x2&&x2==x3&&x3==x4&&x4==x5&&x5==x6)
        {
            flag=1;
            cout<<a[p[1]];//当前位置
            return ;
        }
       
    }
    
    for(int i=0;i<9;i++)//0到8序列横向遍历
    {
        if(!st[i])
        {
          st[i]=1;
          p[u]=i;
          dfs(u+1);
          st[i]=0;
          
        }
       
    }
}
int main()
{
    dfs(0);
  
    return 0;
}
~~~

> ==如果用暴力枚举不太方便==
>
> 技巧：巧妙使用排列数求解！！！



> [打表法 使用数组存东西也是很厉害的方法](#单词方阵) 

### 三角序列

**==注意点：无法排除重复情况时直接使用排列组合知识除法去重==**

~~~C++
#include<iostream>
using namespace std;
int a[9]={1,2,3,4,5,6,7,8,9};
//防止镜像和旋转和重复
int p[10];
bool st[10];
int ans;

bool check(int p[])
{
    int a=p[0]+p[1]+p[2]+p[3];
    int b=p[3]+p[4]+p[5]+p[6];
    int c=p[6]+p[7]+p[8]+p[0];
    if(a==b&&b==c)
    return 1;
    else
    return 0;
}
void dfs(int u)
{
    if(u==9)
    {
        if(check(p))
            ans++;
        return ;
    }
    
    
    for(int i=1;i<=9;i++)
    {
        if(!st[i])
        {
            st[i]=1;
            p[u]=i;
            dfs(u+1);
            st[i]=0;
        }
    }
}
int main()
{
    
    dfs(0);
    --------------------------------------
    cout<<ans/6;//重复个数
    --------------------------------------
    
    return 0;
}
~~~



### 剪邮票（思考错&对-->**巩固回溯知识）**调试的功劳！！！

![image-20241004131745527](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241004131745527.png)

#### 正确答案

~~~C++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int N = 1e8;
int mp[100][200];
bool st[100][200];

long long ans;
int dx[] = { -1,-1,0,1,1,1,0,-1 };
int dy[] = { 0,1,1,1,0,-1,-1,-1 };
bool pro_st[N];
vector<int>p(5);


bool num_st[N];
void dfs(int x, int y, int u)
{
    if (x <= 0 || y <= 0 || x > 3 || y > 4)return;
    if (st[x][y])return;

 
    if (u == 5)//重点   --->u==4 （X）
    {
        vector<int>a = p;
        sort(a.begin(), a.end());
        int t=a[0]*100000+a[1]*10000+a[2]*1000+a[3]*100+a[4];
        if(!pro_st[t])
        {
            pro_st[t]=true;
            ans++;
        }
        
        // for (int i = 0; i < a.size(); i++)cout << a[i] << ' ';
        // cout << endl;

        return;
    }  
    st[x][y] = 1;
    p[u] = mp[x][y];
    //返回时要注意
    for (int i = 0; i < 8; i++)
    {
        dfs(x + dx[i], y + dy[i], u + 1);
       
   


    }
         st[x][y] = 0;

}

int main()
{
    int cnt = 1;
    for (int i = 1; i <= 3; i++)
        for (int j = 1; j <= 4; j++)
            mp[i][j] = cnt++;

     for(int i=1;i<=3;i++)
        for(int j=1;j<=4;j++)
               dfs(i, j, 0);
    cout << ans;


    return 0;
}
~~~

#### 错误答案

~~~c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int N = 1e8;
int mp[100][200];
bool st[100][200];

long long ans;
int dx[] = { -1,-1,0,1,1,1,0,-1 };
int dy[] = { 0,1,1,1,0,-1,-1,-1 };
bool pro_st[N];
vector<int>p(5);


bool num_st[N];
void dfs(int x, int y, int u)
{
    if (x <= 0 || y <= 0 || x > 3 || y > 4)return;
    if (st[x][y])return;

    st[x][y] = 1;
    p[u] = mp[x][y];
    if (u == 4)
    {
        vector<int>a = p;
        sort(a.begin(), a.end());
        for (int i = 0; i < a.size(); i++)cout << a[i] << ' ';
        cout << endl;

        return;
    }
    for (int i = 0; i < 8; i++)
    {
        dfs(x + dx[i], y + dy[i], u + 1);
        st[x + dx[i]][y + dy[i]] = 0;


    }

}

int main()
{
    int cnt = 1;
    for (int i = 1; i <= 3; i++)
        for (int j = 1; j <= 4; j++)
            mp[i][j] = cnt++;

    //  for(int i=1;i<=3;i++)
    //     for(int j=1;j<=4;j++)
    dfs(1, 1, 0);
    cout << ans;


    return 0;
}
~~~

#### 使用bfs判断连通块



### 迷宫

### dfs暴力超时了



~~~C++
#include<iostream>
using namespace std;
int dx[]={1,-1,0,0};
int dy[]={0,0,-1,1};
const string pat="DULR";
char a[40][60];
string str_min;
string res="";
int cnt;
bool st[40][60];
void dfs(int x,int y)
{

    if(x>30||x<=0||y<=0||y>50)return ;
    if(st[x][y])return ;
    if(a[x][y]=='1')
    return ;
    
    if(!str_min.empty() && res.size() > str_min.size()) return;//赋值前不能返回
    

    if(x==30&&y==50)
    {
       cnt++;//统计方案数
       if(cnt==1)//第一次进去时默认最小值
       {
          str_min=res;
          return ;
       }
       else //之后进去的时候开始更新
       {
           if(str_min.size()>res.size())
           str_min=res;
       }
        
        return ;
    }
    
    st[x][y]=1;
    for(int i=0;i<4;i++)
    {
        res.push_back(pat[i]);
        dfs(x+dx[i],y+dy[i]);
        res.pop_back();
        
    }
    st[x][y]=0;
    
}
int main()
{
   
    for(int i=1;i<=30;i++)
        for(int j=1;j<=50;j++)
            cin>>a[i][j];
            
         
            
            
    dfs(1,1);//起点
    cout<<str_min<<endl;
  

    return 0;
}
~~~

### bfs

~~~C++
#include<iostream>
#include<queue>
#include<string.h>
using namespace std;
typedef pair<int,int> PII;
int dx[]={1,0,0,-1};
int dy[]={0,-1,1,0};
char a[40][60];
int n,m;
int d[40][60];//距离数组
int x,y;
string trace[40][60];
const string pat="DLRU";
string Min;

void bfs()
{
  queue<PII>q;
  q.push({1,1});//将起点加入
 
  while(!q.empty())
  {
      auto t=q.front();
      q.pop();
      
      for(int i=0;i<4;i++)
      {
         x=t.first+dx[i];
         y=t.second+dy[i];
          //先走再判断是否合法
          if(x>n||y>m||x<=0||y<=0||d[x][y]!=-1||a[x][y]=='1')
            continue;//不合法就返回（return）
          -----------------------------------------------------
            d[x][y]=d[t.first][t.second]+1;//同时起到判重的功能
            trace[x][y]=trace[t.first][t.second]+pat[i];//!!
          -----------------------------------------------------
        q.push({x,y});
        //疑惑点：为什么d[x][y]就是起点到x y的最短距离  
          //因为 
          //在bfs中我们能维护什么？！
          
      }  
  }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
            
            memset(d,-1,sizeof d);
            d[1][1]=0;
    bfs();
    cout<<trace[n][m];
    
    
    return 0;
}
~~~

==bfs一般维护某个想要的功能就直接建立二维数组就好了== 

> last 数组实现路径查询
>
> d数组实现距离查询



==bfs本质 ： 每次走都是起点到当前坐标的最短路径==

每个格子都是有唯一维护的数组值（e.g. d距离），不会冲突

## 暴力枚举

### 学会多重循环的逻辑

[子矩阵枚举](#暴力法)

![](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241003132655245.png)

~~~C++
#include<iostream>
using namespace std;

int ans;
int main()
{
    //以下continue（return）逻辑循环保证了没有一个数分子分母是是相同的
    //四重循环枚举
    //首先由题目得出两个数的分子分母都不能一模一样
    //然后根据数学运算证明一个数分子分母相同的时候，一个数分子分母不相同的时候是无法使以下等式成立的
    //所以可以忽略，因此可以使用以下的continue（类比return）逻辑
    
    for(int i=1;i<=9;i++)//枚举第一个数的分子
    {
        for(int j=1;j<=9;j++)//枚举第一个数的分母
        {
            if(j==i)
            continue;
            for(int m=1;m<=9;m++)
            {
                for(int n=1;n<=9;n++)
                {
                    if(n==m)
                    continue;
                    
                    if(i*m*(j*10+n)==j*n*(i*10+m))
                    ans++;
                }
            }
        }
    }
    cout<<ans;//不用除2，不会重复，因为拼接是有顺序之分的！
    return 0;
}
~~~

![e7602f2a31a6f3c075302a1c6fe1134](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/e7602f2a31a6f3c075302a1c6fe1134.jpg)



### dfs 超时 使用 暴力枚举

![image-20241005203005326](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241005203005326.png)

#### dfs（可能可以剪枝优化）

~~~C++
#include<iostream>
using namespace std;
int ans;
int p[10];
bool st[10000];
int sum=0;
int n;
bool kasa(int x)
{
    while(x)
    {
        if(x%10==2||x%10==4)return 0;
        x/=10;    
    }
    return 1;
}

void dfs(int u)
{
    if(sum>n)return ;
    if(u!=0&&!kasa(p[u-1]))return ;
    
    if(u==3&&sum==n)
    {
        for(int i=0;i<3;i++)
        {
            cout<<p[i]<<" ";
            
        }
        cout<<endl;
        return ;
    }
    
    for(int i=1;i<=n-sum;i++)//记录当前层的sum总和
    {
        if(!st[i]&&u==0||i>p[u-1])
        {
            st[i]=1;
            p[u]=i;
            sum+=i;
            dfs(u+1);
            sum-=i;
            st[i]=0;
        }
    }
}

int main()
{
   
    cin>>n;
    dfs(0);
    cout<<ans;
    
    
    return 0;
}
~~~

#### 暴力枚举（超时版）

~~~C++
#include<iostream>
using namespace std;

bool check(int x)
{
    while(x)
    {
        if(x%10==2||x%10==4)return 0;
        x/=10;    
    }
    return 1;
}
int main()
{
    int ans=0;//记录答案
    //a b c
    for(int a=1;a<=700;a++)
    {
        if(check(a))
        continue;
        for(int b=a+1;b<=2019-a-a;b++)
        {
            if(check(b))
            continue;
            for(int c=b+1;c<=2019-a-b;c++)
            {
                if(check(c))
                continue;
                if(a+c+b==2019)
                ans++;
            }
            
        }
    }
    cout<<ans;
    
    return 0;
    
}
~~~

#### 暴力枚举（优化版）

~~~C++
#include<iostream>
using namespace std;

bool check(int x)
{
    while(x)
    {
        if(x%10==2||x%10==4)return 0;
        x/=10;    
    }
    return 1;
}
int main()
{
    int ans=0;//记录答案
    //a b c
    ---------------------------------------
    for(int a=1;a<700;a++)
    {
        if(!check(a))
        continue;
        for(int b=a+1;b<2019-a-a;b++)//优化枚举和优化循环层数
        {
            if(a+b>=2019)
            break;
            if(!check(b))
            continue;
            if(!check(2019-a-b))
            continue;
            if(2019-a-b>b)
            ans++;
           
            
        }
    }
    -----------------------------------------
        //去重干脆就直接让他们顺序或者逆序排列
    cout<<ans;
    
    return 0;
    
}
~~~

## 拔河

### 暴力枚举超时

~~~C++
#include<iostream>
#include<cmath>
using namespace std;
const int N=1e3+10;
#define int long long
int a[N];
int s[N];
int Min=9999999;
signed main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)s[i]=a[i]+s[i-1];
    
    //枚举
    //如何优化
    //！！！！！
    for(int i=1;i<n;i++)
    {
        for(int j=i;j<n;j++)
        {
            int sum1=s[j]-s[i-1];
            for(int k=j+1;k<=n;k++)
            {
                for(int l=k;l<=n;l++)
                {
                    int sum2=s[l]-s[k-1];
                    Min=min(Min,abs(sum1 - sum2));
                }
            }
          
           
        }
    }
    cout<<Min;
    return 0;
}
~~~

### 优化多重循环
(与统计子矩阵类似 都是用==双指针==优化)

[统计子矩阵](#前缀和+双指针)

#### 二分set法

~~~###
~~~



#### 双指针优化

~~~~C++
~~~~



## 外卖店优先级（模拟）

### 暴力+二维map映射

~~~C++
#include<iostream>
#include<map>
using namespace std;
const int N=1e5+10;
map<int,map<int,int>>mp;
map<int,int>cnt;
map<int,bool> flag;//标记优先缓存
//都使用map防止mle ，起到了离散化的作用
//不用开辟一整段连续的内存空间
int main()
{
    int n,m,t;
    cin>>n>>m>>t;
    
    for(int i=0;i<m;i++)
    {
        int ts;
        int id;
        cin>>ts>>id;
        mp[ts][id]++;
    }
    for(int i=1;i<=t;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(mp[i][j])
            {
              cnt[j]+=mp[i][j]*2;  
            }
            else if(cnt[j])
            {
                cnt[j]--;
                
            }
            
            if(flag[j]&&cnt[j]<=3)
            {
                flag[j]=0;
            }
            else if(!flag[j]&&cnt[j]>5)
            {
                flag[j]=1;//进入优先缓存
            }
            
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(flag[i])
            ans++;
    }
    cout<<ans;
   
    return 0;
}
~~~

### 方法（功能）数组+递推

~~~C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N=100010;
typedef pair<int,int> PII;
PII order[N];
bool vis[N];
//确认是否在优先缓存内
int res; //记录答案
int last[N]; //记录上一个点有订单的时刻
//映射关系注意（把它当函数）
int score[N]; //分数
//我们要把数组当作一个函数（数据集的一个映射）

int main()
{
    int n, m, T;
    scanf("%d %d %d", &n, &m, &T);
    int k = 1;
    int M = m;
    
    while (M--)
    {
        int x, y;
        scanf("%d %d", &x, &y);
        order[k++] = {x, y}; //k最后一定会多1
    }
    
    sort(order, order + k); //k-1个数
    //排序按照时刻优先排序
    //pair排序的默认关键字
    
    for (int i = 1; i < m;) //枚举订单
    {
        int j = i; //把这个放在括号内和外是不一样的
        
        while (j <= m && order[i] == order[j]) j++; //处理一批订单
        
        int cnt = j - i; //订单量
        int t = order[i].first, ID = order[i].second; //提取当前结构体成员变量
        i = j; //指针瞬移,j接着去扫描后续订单
        
        score[ID] -= (t - last[ID] - 1); //这一次和上一次中间有没有时间是没有订单的
        if (score[ID] < 0) score[ID] = 0; //保证数据合法
        
        // score[ID]+=cnt*2;  为什么放这里不行
            
        if (score[ID] <= 3) vis[ID] = 0;
            score[ID] += cnt * 2;
        if (score[ID] > 5) vis[ID] = 1;
        //减操作
        
        last[ID] = t; //递推
        //将当前时间赋给上一个时间记录数组并且move到下一层
    }
    
    //特判：能否处理一个订单和多个订单
    
    //扫尾
    //万一订单中最晚时间到t时刻都没有订单的话怎么办
    //因为上面的逻辑就是只有订单中有这个店铺才会处理这个店铺
    for (int i = 1; i <= n; i++) //枚举每一个店铺编号
    {
        if (last[i] < T)
            score[i] -= T - last[i]; //!!!!
        if (score[i] <= 3) vis[i] = 0;
        if (score[i] < 0)
            score[i] = 0;
    }
           
    for (int i = 1; i <= n; i++)
        res += vis[i];
    
    cout << res;
    
    return 0;
}
~~~

位置问题：如果放在那边

如果 score[ID] 的初始值和 cnt 的值使得 score[ID] 在增加后总是大于 5，那么两个代码片段的结果确实会一样，因为最终都会设置 vis[ID] = 1。

•  但是，如果 score[ID] 的初始值和 cnt 的值使得 score[ID] 在增加后仍然小于或等于 5，那么两个代码片段的结果可能会不同。

举例子： 一开始要是2号店铺已经在优先缓存中了 然后 之后由于没有订单优先缓存小于3了但是 当前时刻订单数累计起来虽然没超过5但是比3大就说明要重置状态为0了因为一旦到了某时刻就要判断



## 染色/带分数 切割区间法

![image-20241013201125420](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241013201125420.png)

~~~C++
#include<iostream>
using namespace std;
int st[10];
int ans;
int n;
int p[10];//存排列数

int calc(int l, int r,int p[]) {
  int res = 0;
  for (int i = l; i <= r; i++) {
    res = res * 10 + p[i];
  }
  return res;
}

//数组计算为整数

void dfs(int u)
{
   if (u == 9) {
       //枚举区间 切割区间
    for (int i = 0; i < 7; i++) {
      for (int j = i + 1; j < 8; j++) {
        int a = calc(0, i,p);
        int b = calc(i + 1, j,p);
        int c = calc(j + 1, 8,p);
        // 注意判断条件，因为C++中除法是整除，所以要转化为  加减乘  来计算 !!!!!!!!
        if (a * c + b == c * n) {
          ans++;
        }
      }
    }
    return;
  }
    
   
   for(int i=1;i<=9;i++)
   {
       if(!st[i])
       {
           st[i]=1;
           p[u]=i;
           dfs(u+1);
           st[i]=0;
       }
   }
}
int main()
{
  
    cin>>n;
    dfs(0);
    cout<<ans;
    // cout<<len;
    return 0;
}
~~~

**生成全排列 拆分（切割区间选数字）！！**
**移动项数避免除法**





# ==三、模拟==

## 飞机时间

![image-20241006154425162](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241006154425162.png)

~~~C++
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int w1=0;
        int w2=0;
        int h1,m1,s1,h2,m2,s2;
        int h3,m3,s3,h4,m4,s4;
        //格式化读入不用担心读入错误
        scanf("%d:%d:%d",&h1,&m1,&s1);
        int t1=3600*h1+60*m1+s1;
        scanf("%d:%d:%d (+%d)",&h2,&m2,&s2,&w1);
        int t2=3600*(h2+24*w1)+60*m2+s2;
        
        //A->B
        scanf("%d:%d:%d",&h3,&m3,&s3);
        int t3=3600*h3+60*m3+s3;
        scanf("%d:%d:%d (+%d)",&h4,&m4,&s4,&w2);
        int t4=3600*(h4+24*w2)+60*m4+s4;
         //B->A
         
        int gap=((t2-t1)-(t4-t3))/2;
        //飞行时间
        int ss=t2-gap-t1;//为什么是这么计算的
        
        printf("%02d:%02d:%02d\n",ss/3600,ss%3600/60,ss%60);
      
        
        
        
       
    
        
    }
    
    return 0;
}
~~~

![image-20241006155210266](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241006155210266.png)

**gap不管正还是负就按假设的来**

**`此题问题：`**

**`1.输入问题`**

**`2.计算时差问题`**

**`3.理解题目的速度以及能力`**

## 海港

![image-20241006173615271](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241006173615271.png)

### stl使用优化（但是还是超时）

~~~C++
#include <iostream>
#include <vector>
#include <map>
#include <queue>
#include <set>
using namespace std;

struct boat {
    int t; // 到达时间
    int k; // 乘客数
    vector<int> nation;
};

int main() {
    int n;
    cin >> n;
    vector<boat> a(n);
    ------------------------------------------------
    queue<pair<int, int>> tim; // 存储到达时间和船的索引
    ------------------------------------------------
    
    map<int, int> nation_count; // 记录每个国家的乘客数
    int current_unique_nations = 0;//答案

    for (int i = 0; i < n; i++) {
        cin >> a[i].t >> a[i].k;
        a[i].nation.resize(a[i].k);
        for (int j = 0; j < a[i].k; j++) {
            cin >> a[i].nation[j];
        }

        tim.push({a[i].t, i});

        // 移除超过86400秒前的船只
        while (!tim.empty() && a[i].t - tim.front().first >= 86400) //判空一定要放在最前面
            
        {
            int old_boat_index = tim.front().second;
            tim.pop();
            for (int nation : a[old_boat_index].nation) {
                nation_count[nation]--;
                if (nation_count[nation] == 0) {
                    nation_count.erase(nation);
                    current_unique_nations--;
                }
            }
        }

        // 添加当前船的乘客
        for (int nation : a[i].nation) {
            if (nation_count[nation] == 0) {
                current_unique_nations++;
            }
            nation_count[nation]++;
        }

        cout << current_unique_nations << endl;
    }

    return 0;
}
~~~

### 超时建议（复杂）

~~~c++
#include <iostream>
#include <vector>
#include<map>
#include<queue>
#include<set>
using namespace std;

set<int>flag[100000];
map<int,map<int,bool>>st;
queue<int>cnt;
queue<int>tim;
struct boat {
    int t;//到达时间
    int k;//乘客数
   vector<int>nation;
};
int head=0;
int main() {
    int n;
    cin >> n;
    vector<boat> a(n);  // 动态创建n个boat结构体
    int w=0;
    for (int i = 0; i < n; i++) {  // 注意索引从0开始
        cin >> a[i].t >> a[i].k;      
        tim.push(a[i].t);          
       while(tim.size()&&a[i].t-tim.front()>=86400)//弹出时要保证不为空
       {
           tim.pop();
           for(int m=0;m<a[w].k;m++)//枚举当前船上所有乘客
           {
               st[w][a[w].nation[m]]=0;               
           }
           int nn=flag[w].size();
            while(nn--)cnt.pop();
          w++; 
       }  
       a[i].nation.resize(a[i].k);  // 动态调整nation的大小
        for (int j = 0; j < a[i].k; j++) {
          cin >> a[i].nation[j];  // 索引从0开始
            if(!st[i][a[i].nation[j]])
            {
              st[i][a[i].nation[j]]=1;
              cnt.push(a[i].nation[j]);         
            }
            flag[i].insert(a[i].nation[j]);
        
        }
         set<int>s;
         queue<int> q_copy = cnt; // 复制 queue
          while (!q_copy.empty()) {
        s.insert(q_copy.front());
        q_copy.pop();
    }
      
        cout<<s.size()<<endl;
     
    }
    
    return 0;
}
~~~





![image-20241006173625755](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241006173625755.png)



### 自己代码（终极）优化

~~~C++
#include <iostream>
#include <vector>
#include<map>
#include<queue>
#include<set>
using namespace std;
queue<int>cnt;
map<int,int>st;
int ans;//j记录答案
struct node
{
  int tt;
  int na;
};
struct boat {
    int t;//到达时间
    int k;//乘客数
   vector<int>nation;

};
int main() {
    int n;
    cin >> n;
    queue<node>tim;
    vector<boat> a(n);  // 动态创建n个boat结构体
  
    for (int i = 0; i < n; i++) {  // 注意索引从0开始
        cin >> a[i].t >> a[i].k;
            //弹出 所有 时刻是某时刻的国家数
       while(tim.size()&&a[i].t-tim.front().tt>=86400)//弹出时要保证不为空
       {
          //tim除了存时间，再存一个国家会更好
          st[tim.front().na]--;
          if(st[tim.front().na]==0)
          ans--;
          
          tim.pop();

       }
    
       a[i].nation.resize(a[i].k);  // 动态调整nation的大小
        for (int j = 0; j < a[i].k; j++) {
          cin >> a[i].nation[j];  // 索引从0开始
        
          if(st[a[i].nation[j]]==0)
          ans++; 
          st[a[i].nation[j]]++;
          tim.push({a[i].t,a[i].nation[j]});
          
        }
        
        cout<<ans<<endl;
        
     
    }
  
    
    return 0;
}
~~~



### sum 经验

1.结构体中成员数组最好开动态数组

2.map<int,map<int,int>> 二维map内部数据结构顺序别写错了

3.a[i].nation.resize(a[i].k);  resize用法避免开太大内存空间

4.结构体（结点）存入stl中，避免多重嵌套数据结构

5.使用结构体可以让一个元素存更多的数据信息

6.st状态数组也可用于记录次数维护逻辑

7.最好别用map（可用静态数组存储时）



![image-20241006182718062](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241006182718062.png)

# 四、stl使用技巧

## hash

![image-20241007093857337](https://cdn.jsdelivr.net/gh/kasahuki/os_test@main/img/image-20241007093857337.png)

~~~C++
class Solution {
public:
    vector<int> findNumbersWithSum(vector<int>& nums, int target) {
        map<int,int>mp;
        vector<int>ans;
        for(auto item:nums)
        {
            if(mp.find(target-item)!=mp.end())
            {
                ans.push_back(item);
                ans.push_back(target-item);
                return ans;
            }
            
            mp[item]=1;
        }
    }
};
~~~

**一边存一边处理，有效避免重复问题，e.g. target =10 里面只有一个5 如果提前存，就会错，因为会查到本身；**

[类似技巧](#二分法)



# 算法考研

## 线性表



## 二叉树&树



## 图



## 查找



## 排序

